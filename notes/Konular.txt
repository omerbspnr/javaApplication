- Java Uygulama kursu -
--------------------------------------------------------------------------------------------------------------
                                            01.03.2020
--------------------------------------------------------------------------------------------------------------

- Bir algoritmanın karmaşıklığı iki şeye bağlıdır.
    - Hız
    - Kaynak kullanımı


- Big O notation
    - Büyük O harfinin içerisine n'e bağlı bir denklem yazılır.
      O(1)// Sabit karmaşıklık // döngü yok anlamında, Örneğin dizi erişimi
      O(n) // lineer(doğrusal) karmaşıklık // tek döngü içeren algoritma // dizinin elemanları toplamı
      O(n ^ 2) // Karesel karmaşıklık iç içe döngü içeren(iki tane) algoritma // matrisin  elemanları toplamı
      O(n ^ 3) // Küpsel karmaşıklık
--------------------------------------------------------------------------------------------------------------
                                            StrinBuilder class
--------------------------------------------------------------------------------------------------------------

- String sınıfı immutable(içerisindeki veri değiştirimez) özelliğe sahip iken,
  StringBuilder sınıfının içerisindeki veri değiştirilebilir.

- String sınıfı türünden runtime'da atanan(Örneğin klavyeden girilen yada new operatörü ile oluşturaln) aynı
  yazılar birbirinden farklı adresler üretir.
    - Yukarıdaki olayda derleyicinin olayın içinde olmadığı için bellekte aynı yer ayrılmaz.
    - String s = "ankara";
    - String str = "ankara"; // derleyici "ankara" yazısı için tek bir adres üretir. Eğer bu nesneler new operatörü ile
      yaratılsaydı farklı adresler üretilirdi.

- Derleme zamanında çözülecek bir sorun var ise derleme zamanında çözülür.


- StringBuilder sınıfı String sınıfının mutable halidir(StringBuilder içerde char türünden dizi tutar, String sınıfı
  içerisinde CharSequence denilen bir tür vardır.)

- StringBuilder sınıfının size ve capacity denilen iki tane fonksiyonu vardır.
  Size içeride tutulan yazının uzunluğunu döndürür.
  Capacity ise maksimum artırılabilecek size'ı gösterir.(Capacity aşıldığında StringBuilder nesnesi için
  yeni bir yer tahsis edilir)

- amortized constant time (Çoğu zaman O(1) bazen ise O(n) karmaşıklığa çıkabilen karmaşıklıktır.)

- StringBuilder amortized constant time karmaşıklığı ile çalışan bir yapıya sahiptir.

- StringBuilder sınıfı içsel olarak tuttuğu dizinin elemanına capacity denir. Bizim tuttuğumuz veri eleman sayısına
  size, yada length denir.

- StringBuilder String sınıfı için yardımcı bir türdür.

- StringBuilder ctor'ları
    - default (16 karakterlik yer tutar.)
    - int capacity parametreli ctor (capacity'nin tarafımızdan belirlendiği durumlar)
    - String parametreli (String.length'i artı 16 karakterlik yer tutar.)

- Java'da bir programcı bir nesnenin hayatına son veremez.(C++' daki delete işlemi dinamik bir nesnenin hayatını sona erdirir.)

- StringBuilder türüne String türünden bir nesne atanmaz. StringBuilder s = "ankara";//error

- StringBuilder sınıfının String parametreli ctor elemanı vardır.
    StringBuilder sb = new StringBuilder(String s);

- StringBuilder sınıfının toString fonksiyonu String döndürür.

- String ve StringBuilder sınıfının indexOf methodları char parametre ile değil, string paremetre ile çalışır.

--------------------------------------------------------------------------------------------------------------
                                            07.03.2020
--------------------------------------------------------------------------------------------------------------


- StringBuilder sınıfı türünden nesne initialize edilirken verilen Stringin uzunluğu artı 16 byte'lık yer ayırır.

- delete metodu StringBuilder sınıfında verilen range'i silip kaydırma yapar.
   sb.delate(int begin, int end); [begin,end);

- getChars metodu verilen bir char array'inin içini doldurur. Herhangi bir StringBuilder sınıfının
    sb.getChars(int srcBegin,int srcEnd,char [] chars, int destBegin); //

- terim olarak append ve add fiilleri programlama da sona eklemek için kullanılır.

- insert belirli bir konuma ekleme yapar. bunun sonunda bir kaydırma işlemi yapılır.

- StringBuilder sınıfının setLength fonksiyonu length'i artırır ve geri kalan kısmı null character ile doldurur.

- setLength isimli fonksiyonu aynı zamanda küçültme de yapmamızı sağlar.

- StringBuilder sınıfının fonksiyonları
    - ensureCapacity(int val); // artırılacak minimum kapasiti değerinden küçük ise kendisi minimum değeri atar.
      Değilse bizim bildirdiğimiz değeri artar.

      StringBuilder sb = new StringBuilder("ankara"); // capacity 22
      sb.ensureCapacity(23); // capacity 46 artması gereken değer 46 olacağı için 46'ya çıkmıştır.
      sb.ensurecapacity(150); // capacity 150

    - Ya bizim verdiğimiz gereken değere çeker yada artmasa gereken değere çeker.

    - ensureCapacity değeri varolan değerden daha küçük bir değere artar.


- setCharAt fonksiyonu geçersiz length durumlarında exception throw eder.
- StringBuilder sınıfının char arayan bir indexOf fonksiyonu yoktur. String sınıfının vardır.

- subSequence(int start, int end) methodu yazı olabilen sınıflar için kullanılabilir. charSequence türüne geri döner.
  charSequence demek String demek değildir. Ama String demek charSequence demektir.

- trimToSize(); Sınıfın capacity'sini length'ine eşitler.

--------------------------------------------------------------------------------------------------------------
                                            BigDecimal class
--------------------------------------------------------------------------------------------------------------

- switch deyimlerinde double türleriyle karşılaştırma yapılamaz.

- double sayıları karşılaştırılken epsilon değeri ile karşılaştırılır.

- double sayıların kritik yerlerde kullanımı özellikle finansal uygulamalar da ortaya çıkar ve sorunları burada belli olur.

- BigDecimal sınıfı immutable'dır.
- Sınıflarda referans karşılaştırması ile nesnelerin gösterdikleri değerlerin aynı olup olmadığını
  == operatörü ile değil sınıfın ilgili metodları ile(equals, compareTo), metodları ile yapılmalıdır.
- BigDecimal sınıfının add metodu iki BigDecimal türünden nesneyi toplar.


- BigDecimal sınııfının valueOf metodu double türler için yuvarlama hatası olmaz. Verilen sayının kanonikal formunu döndürür.
  Sayı fonksiyona verilmeden önce yuvarlanmış ise kanonikal forma göre de  yuvarlanmış şekilde sayıdan nesne üretir.

- BigDecimal sınıfının min ve max metotları vardır.

- BigDecimal sınıfının public static final bazı  veri elemanları
    - BigDecimal.ZERO
    - BigDecimal.TEN
    - BigDecimal.ONE


--------------------------------------------------------------------------------------------------------------
                                            08.03.2020
--------------------------------------------------------------------------------------------------------------


- BigDecimal sınıfının compareTo metodu karşılaştırma yapar.
    bd1.compareTo(bd2)
    Değer +1 ise bd1 > bd2(bunlar içeride tutulan değere göre karşılaştırma yapılır.)
    değer -1 ise bd1 < bd2
    değer 0 ise bd1 == bd2 olur.


- iki tane sayının max'ını elde ederken yeni bir nesne elde edilmez. Verilen adreslerden hangisinin gösterdiği
  değer büyük ise o referans geri döndürülür.


- BigDecimal sınıfının non-static divide metodu,
    a.divide(Bigdecimal number, int scale, RoundingMode )
        scale .'dan sonra kaç tane basamak verileceğini bilir.
        RoundingMode'da enum türünden bir sınıftır.RoundingMode'ın belirli değerleri vardır.(RoundingMode.HALF_UP //gibi)
        RoundingMode ile yuvarlamanın nasıl yapılacağı belirtilir.



--------------------------------------------------------------------------------------------------------------
                                Bir Library(Jar dosyası) nasıl oluşturulur(intellij için)
--------------------------------------------------------------------------------------------------------------
- Java da her bir moduül birer projedir.
- Her bir modülün birer main'i olabilir.
- Jar dosyaları aşağıdaki biçimde oluşturulur.
    1- Öncelikli olarak sınıfın içindeki kodlar yazılmış olmalı
    2- project structure'dan artifact(çıktı olarak kullanılır)'s kısmından yeni bir artifact oluşturulur.
    3- Artifact'in üst taraftaki ısmı değil ancak aşağı taraftaki ismi başına alan adı şeklralinde eklenir.
       (org-csystem-mathlib) - olmasının nedeni dosya olacağı için nokta koyamamızdan kaynaklıdır.
    4- Build kısmından oluşturulan artifact'ler build artifacts seçeneği ile build edilir.
--------------------------------------------------------------------------------------------------------------
                                Bir Library(Jar dosyası) nasıl projeye eklenir(intellij için)
--------------------------------------------------------------------------------------------------------------

- Öncelikli olarak library'ler projeye eklenirken proje klasörümüzde bu jar dosyalarını bulunduracağımız,
  bir klasör de olması daha iyi olur.(İsmi libs olabilir)
  Bu klasörde bulunan dosyaları eklemek için projects structure'dan library sekmesine tıklayarak ilgili
  jar dosyaları projelerimizi ekliyoruz. Bu dosyaları projemizde ekleyeceğimiz modülü seçebiliriz.

--------------------------------------------------------------------------------------------------------------
                                                14.03.2020
--------------------------------------------------------------------------------------------------------------

- SimpleProductMenuApp uygulaması yapıldı.


--------------------------------------------------------------------------------------------------------------
                                                15.03.2020
--------------------------------------------------------------------------------------------------------------

- Çalışabilen bir jar için içindeki main fonksiyonu da seçilmelidir(ArrayUtil çalışabilen bir jar değildir.).
  Burada çalışabilen jar'a örnek olarak simple product menuapp'si örnek olarak verilebilir.

--------------------------------------------------------------------------------------------------------------
                                                BIGINTEGER
--------------------------------------------------------------------------------------------------------------

- ONE, TEN TWO, ZERO gibi final static public veri elemanları vardır.

- Önemli fonksiyonlar
    - String parametreli ctor// BigInteger(string val);
    - String ve int radix paramatreli
      //BigInteger(string val, int radix); radix paramatresi  hangi sayı sistemine göre sayının okunacağını belirtir.
       BigInteger("ababab", 16); // sayı 16'lık sistemde okunur.
       BigInteger("765", 8); // sayı 8'lik sayı sistemini göre okunur.
    - static valueOf metodu(long val);

    - sınıfın IntValue ve DoubleValue metodları mevcuttur. Tür dönüşümü yapıp artık bitleri atar.

    - mod almak için mod metodu kullanılır.

- BigInteger sınıfında new operatörü ile yaratılan bir nesne ile final değişkenlerin(BigInteger.ZERO gibi)  == operatörü
  ile karşılaştılması doğru sonucu vermez.
  BigInteger zero = new BigInteger("0");
  System.out.println(zero == BigInteger.ZERO);//false döndürür. Çünkü referans karşılaştırılmasında
  sınıf immutable olmasına rağmen referansın biri new keyword'u ile yaratıldığından dolayı farklı sonuçlar verir.
  Eğer değer valueOf ile alınmış olsaydı sonuç doğru olurdu.(Burası final static değerler için geçerlidir.)

- == operatörü ile yapılan bir karşılaştırma her zaman referans karşılaştırması olur. Bu durumda new operatörü ile yaratılmış
  aynı değere sahip nesneler her zaman farklı adresleri gösterirler.

- Eğer sınıflar'ın valueOf metodu var ise ve immutable sınıf iseler valuOf metodu aynı adres değerlerini döndürür.
    BigInteger.valufeOf(2) == BigInteger.valueOf(2);

--------------------------------------------------------------------------------------------------------------
                            DEĞİŞKEN SAYIDA ARGÜMAN İLE ÇALIŞAN METODLAR.(VARARGS METODLAR)
--------------------------------------------------------------------------------------------------------------

- Metod ne şekilde yazılırsa yazılsın metodun içindeki parametre değişkeni dizi referansıdır.
- Böyle fonksiyonlar değişken sayıda yani
      Util.display(10,20,30,40); // derleyici burada new int[]{10,20,30,40} şeklinde bir kod üretir.
      Util.display();
      Util.display(new int[]{1,2})
  argümanları ile çağırılabilir.

- class Util {
    public static void display(int ...a) // değişken sayıda int türden eleman alabilir.
    {
        //... atomuna elipsis atomu denir.
    }
  }

- elipsis atomu dilden dile farklı şekilde yazılabilir.

- varags bir metod [] referansı ile overload edilemez.
    public void display(int [] a);
    public void display(int ...a); // ikisinin aynı anda olması errordur.

- Bunun dışında fonksiyon herhangi bir parametre ile overload edilebilir.

- Bir metodun bir elipsis parametresi var ise elipsis parametresi en sondaki parametre olmalıdır.
    void display(int ... a, int n) ;//error

- Bir metodun birden fazla elipsis parametresi olamaz.
  public static void display(int ...a, String ...b) // error

- printf fonksiyonun birincisi parametresi String s, ikinci parametresi Object ... args'dır.

- iki tane varags parametreli metod yazılmak istenirse biri dizi referansı yapılmalıdır.

- matrisler le elipsis işlemi yapmak için fonksiyon parametresi
  class Util {
    public static void display(int [] ... a)
    {

    }
  }

- varargs metodlar sadece fonksiyon bildiriminde bulunabilir. Bunun dışında değişken bildiriminde yada sınıf bildirimin
  de bulunamazlar.

- Burada fonksiyona geçilecek parametre ya elipsis atomundan önceki atom türünden 0 yada en az 1 adet olmalı,
  yada elipsis atomunu da kapsayacak şekilde (int ... a için int [], int [] ... a için  int [] []) bir adet argüman
  gönderilebilir.


--------------------------------------------------------------------------------------------------------------
                                                21.03.2020
--------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------
                                                KOMUT SATIRI ARGÜMANLARI
--------------------------------------------------------------------------------------------------------------

- Özellikle bazı server uygulamalarında kullanılmaktadır.
- komut satırı argümanlarının uygulamaya geçilmesi için uygulamanın konsolda çalışması gerekmektedir.
- komut satırından uygulamayı çalıştırmak için, console'dan
    - java org.csystem.app.App <argümanlar>

    - eğer uygulama bir çalışabilen jar dosyası olarak çıkarıldı ise
      java -jar şeklinde <applicationname> <argümanlar> şeklinde çalıştırılmalıdır.
--------------------------------------------------------------------------------------------------------------
                                                var keyword
--------------------------------------------------------------------------------------------------------------

- Java 10 ile eklenmiştir. Yerel değişken bildirimlerinde kullanılır.
- Java 11 ile birlikte lambda ifadelerinde de kullanılmaya başlanmıştır.

- var anahtar sözcüğü değişken ismi olarak kullanılabilir.

- var anahtar sözcüğü ile belirtilen değişkene ilk değer verilmesi zorunludur.
  Çünkü değişken türünü  verilen ilk değere göre belirlenir
  var a = 10; // a'nın türü 10 olarak belirlenmiştir.

- var anahtar  sözcüğünün büyük özelliği kod yazımını basitleştirmektir.

- var anahtar sözcüğü parametre değişkeni bildiriminde kullanılamaz.

- var bir sınıfın veri elemanı olarak ta belirlenemez.

- sadece yerel değişkenler(Dikkat for deyiminin içi bir yerel bloktur.) ve lambda ifadelerinde kullanılır.

-

--------------------------------------------------------------------------------------------------------------
                                                22.03.2020
--------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------
                                                Arrays sınıfı
--------------------------------------------------------------------------------------------------------------

- Diziler üzerinde  işlem yapmak için kullanılan bir sınıftır.
- ctor'u private'tır. Metodlarının hepsi static'dir.

- Arrays sınıfının temel işlemler yapan metodları
    - fill metodları
        Arrays.fill(T [] a, int val); // verilen array'i verilen değer ile doldurur;
        Arrays.fill(T [] a, int fromIndex, int toIndex, int val) [fromIndex, toIndex) // verilen array'i index'ler arası
        verilen değer ile doldurur.

    - T [] a copyOf metodu // yeni bir dizi tahsis eder ve değerleri kopyalar, yeni üretilen diziyi küçültebilir.

    - Arrays.fill(T [] a, int newLength); // yeni bir dizi döndürür. newLength ile o uzunlukta bir dizi üretir ve
      dizinin değerlerini kopyalar. diziyi aynı zamanda küçültedebilidir.(Yani eleman sayısı küçültülmüş yeni bir dizi
      verebilir.)

    - T []  copyOfRange(T [] a, int fromIndex,  int toIndex); // copyOf [fromIndex, twoIndex]

    - booleans equals(T [] a, T [] b); // dizilerin eşitlik karşılaştırması yapar.

    - int compare(T [] a, T [] b);
        - Java 9 ile beraber eklenmiştir.
        - Eğer ilk parametredeki dizi büyük ise pozitif, küçük ise negatif, birbirine eşit iseler 0 değerini döner.
        - ilk farklı değer'den büyük olanın değerini döndürür.
        - length'ler farklı ve iki  array'in ilk n(n burada küçük dizinin size'ına kadardır) değeri karşılaştırır.
          eğer burada farklı bir değer var ise döner, eğer değerler eşit ise hangi dizinin size'ı daha büyük ise o
          dizinin bulunduğu konuma göre (Size'ı büyük olan dizi ilk parametre ise pozitif değer, ikinci ise negatif)
          değer döner.



    void sort(T [] a);
        - verilen diziyi küçükten büyüğe sıralar.

    void sort(T [] a, int fromIndex, int toIndex)
        - diziyi [fromIndex, toIndex) bu aralıkta sıralar.

        Büyükten küçüğe de çalışır ancak bunun için collection'lar konusunu görmemiz gerekir.

    String toString() metodları
        Bir diziyi alıp Stringe dönüştürür [] içine alıp delim olaral ,  kullanılır.
        Yazıya çevirirken String sınıfının valueOf metodunu kullanır.

- Javadaki bütün tam sayı türleri pozitif ve negatif sayıları tutulabilir(Yani unsigned bir primitive tür yoktur).

     Arrays.compareUnsigned(int [] a, int [] b)
        - burada sayının negatif değerleri için sayının bitlerini 2'ye tamamlayarak pozitif değere döndürür.

- Genel olarak veri tutan(Data class) Sadece veri tutmaya yarayan sınıfların, toString'i olur.

--------------------------------------------------------------------------------------------------------------
                                                04.04.2020
--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
                                                İçiçe sınıf bildirimleri
--------------------------------------------------------------------------------------------------------------

- 4 biçimde yapılabilir.
    1-) static sınıf bildirimi (nested)
    2-) non-static sınıf bildirimi (inner)
    3-) yerel sınıf bildirimi
    4-) isimsiz sınıf bildirimi


---- Static sınıf(nested) bildirimi ----

- Hiç bir sınıf içerisinde bulunmayan bir sınıf (top level classes) static olarak bildirilimez.
    package org.csystem.app;
    static class  Mycass {} // error

- Bir sınıf içerisinde başka bir sınıf static olarak bildirilebilir. İçteki sınıf dıştaki sınıfın bir elemanıdır.
  Dolayısıyla bir eleman static olabileceğinden sınıfta statik anahtar sözcüğü ile bildirilebilir.

- Tüm elemanlarda olduğu gibi içte bildirilen bir sınıf erişim belirleyicisi olabilir.(public, protected, private, non-modifier)
  Top level classes'ların private olması gibi bir durumu yokken bu inner class'lar için bu durum geçerlidir.

- Static bildirilmiş sınıflar  normal sınaflarda olduğu gibi memberlara(method yada değişkene) sahip olabilirler.

- static bildirilmiş sınıflar onu kapsayan sınıf dışından, kapsadığı sınıf ismi ve . operatörü ile erişilebilir.
    Myclass.innerMyclass b = new Myclass.innerMyclass();
    class Myclass {
        public static class innerMyclass{}
    }

- Bu composition ile karıştırmamak geerekir bu tamamen yeni bir tür bildirimidir.

- import static direktifi ile bu static class'a nitelemeden kullanabiliriz.
    import static org.csystem.app.Myclass.innerMyclass;

- Kapsayan sınıfta static olarak bildirilen sınıfın elemanlarına erişilebilir.

- top level bir sınıftan ilgili sınıfın static member class'ların private elemanına erişilebilir.

- static bir sınıftan kapsayan sınıfın private elemanlarına erişim sağlanabilir.

- static bir sınıfın en büyük artısı içtekinin dıştaki sınıfın yada dıştaki sınıfın içteki sınıfın
  private elemanlarına erişimimizin olmasıdır.

- static sınıflar Builder design pattern'inde sıkça kullanılır. Bunun nedeni sınıfa sanki istediğimiz
  değerler ile yaratma şansımızı verir.

- StringBuilder sınıfıda bir Builder design paterninin sonucudur. Ancak böyle bir şeyin implemente ediliş şekli
  daha farklıdır.

------- non-static(inner) sınıf bildirimi -------

- Bir sınıfın içerisindeki sınıf non-static bildirilmiş ise böyle sınıflara inner class denir

-  inner class'ın static bir member yada static bir methodu olamaz.

- non-static bir sınıf(inner class) türünden bir nesne yaratmak için
    <top_class_name>.<inner_class_name> <variablename> = <top  class reference>.new <innerclass name>();
    A a1 = new A();
    A.B y = a1.new B();
    A.B z = a1.new B(); // şeklinde yapılabilir.

    class A {
      class B{}
    }

- içsel bildirilen bir nesnenin non-static bildirilmiş nesnesine ortada içsel türden bir nesne
  yok ise errordur.
- non static(inner) bildirilmiş bir nesne kapsayan sınıf dışında <referans>.new sentaksı ile
  yaratılabilir.

- inner class'lığın inheritance'lık ile alakası yoktur. Ancak ve ancak bir ilişki veirlecek ise
  aggregation olabilir.

- inner class'lar ilişkin olduğu kapsayan sınıf nesnesinin non-static ve static veri elemanlarına doğrudan erişebilir.

- inner class'lar da içteki nesneyi yaratılabilmek için onu kapsayan sınıf türünden bir nesneye ihtiyaç vardır.

- Genelde inner türden nesneleri dışarıda değilde sınıfın içinde yaratırız.

- static bir fonksiyondan sınıfın non-static bir inner class'ı yaratılamaz.
  Çünkü inner class'ın türünden bir nesne içinde kapsayan türden bir referansın kime ait olacağını
  belirlenemez.

- javac içsel static ve içsel non-static sınıflar için .class dosyasını A$B.class şeklinde
  oluşturur.

- this anahtar sözcüğü non-static metod ile çağırılan referansın adresini gösterir.

- this expression'ının  inner class'lar ile kullanılımı

class A {
    private int m_val;
    public void foo()
    {
        System.out.println("A.foo")
    }
    class B {
        private int m_val;
        public void foo()
        {
            System.out.println("B.foo")
            A.this.foo(); // this expression A::foo çağrılmıştır.
            this.m_val = 10;
            A.this.m_val = 20; //
        }
    }
}


- inner class'larda kapsayan sınıfın bir elemanı ile aynı ise sahip bir member var ise
  top class'ın member'ına erişmek için <top_class_name>.this.member sentaksı kullanılır.
  Bu duruma this expression denir.
  class A {
    private int x;
    class B {
        private int x;
        public void foo()
        {
            System.out.println(A.this.x);
        }
    }
  }
--------------------------------------------------------------------------------------------------------------
                                                05.04.2020
--------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------
                                                Recursive algoritmalar
--------------------------------------------------------------------------------------------------------------

- Özyineleme gerektiğinde kullanılması gereken bir durumdur. Çalışılırken dikkat edilmesi gerekir. Örneğin gömülü
  sistemlerde recursive algoritma hiç tercih edilmez.

- recursive algoritmalar kendini ne kadar çok çağırırsa stack'i o kadar doldurur.

- Eğer recursive algoritmalar yerine  algoritma döngü ile  yapılabiliyor ise(Eğer recursive ile çok daha hızlı
  yapılmıyor ise) recursive function tercih edilmemelidir.

- örneğin factorial fonksiyonu recursive şeklinde yazılmak yerine iteratif şeklinde yazılması daha iyidir.

--------------------------------------------------------------------------------------------------------------
                                                11.04.2020
--------------------------------------------------------------------------------------------------------------

- sınıf içerisinde enum türü bildirilebilir. Doğası gereği new operatörü ile yaratılamayacağı için statik bildirilsin
  yada bildirilmesin statik kabul edilir. Hatta statik bildirilmesine gerek yoktur.


- local classes(yerel sınıflar) :
    - Bir metod içerisinde bildirilen sınıflara  yerel sınıflar denir.

    class Sample {
        public void foo(){
            class A {

            }
            class B{

            }
        }
        public void bar(){
            class A {

            }
            class B{

            }
        }
    }

- Java da her bir sınıf kodu için bir .class dosyası üretilir.
    - local sınıflar için durum : Sample$1A.class şeklinde oluşturur(<taban sınıfı>$<localsınıf ismi>)

- yerel sınıflar faaliyet alanı bakımından bildirildileri fonksiyonun içinde bildirildikleri yerden
  bloğun sonuna kadar görülebilirler.

- yerel sınıflar erişim belirleyicisi  yada statik bildirilmesi gibi bir durumu yoktur. Böyle bir durumda bildirilmesi
  errordur.
  class A {
    public void foo()
    {
          public class B {} // error
          static class C {} // error
    }
  }

- yerel sınıflar başka bir sınıftan(local bir sınıf olabilir.) türetilebilir.(Burada base class'ın türemiş sınıfın
  görebileceği scope içerisinde olması gereklidir sadece).

- yerel bir sınıf kendisinden önce bildirilen yerel değişkenleri ve parametre değişkenlerini yakalayabilir.
  (Buna capture denir.)

  class Sample {
    public void foo(int val)
    {
        int a = 15;
        class Util {
            public boolean isEven(){return val % 2 == 0;}
            public boolean isOdd(){ return val % 2 != 0;}
        }
        var util = new Util();
        sout(util.isEven());
        sout(util.isOdd());
    }
  }

- Java da yerel fonksiyonlar olmadığı için  onların görevini yerel sınıflar ile yapılır.

- Bir yerel değişken bir local sınıf içerisinde kullanılmış(yakalanmış) ise ikinci bir değer atanamaz.
  Değiştirilmiş bir yerel değişkende yakalanamaz.

- Java 8'den itibaren yakalanmış olan yerel veya parametre değişkenlerine effectively final denir.
  Java 8 öncesinde ise yakalanabilecek değişkenler final bildirilmek zorundaydı

- java 8 öncesinde yerel değişkenler de final kullanımı böyle durumlar için geçerliydi

----- Anonim sınıflar -----

- Anonim sınıf bildiriminin genel biçimi aşağıdaki gibidir
  new <tür>([argümanlar]) {};

- Yukarıdaki bildirim bir anonim sınıf bildirimidir, aynı zamanda da bir nesne yaratılması
  işlemidir. Anonim sınıf bildirimi new operatörüne yazılan sınıf türünden türetilmiş olan bir sınıfın
  hem bildirimi hem de o sınıf türünden nesne yaratılması anlamına gelir.

   new Sample(){};
   class Sample {}

- final bir sınıf türünden anonim sınıf yazılamaz.
    new Sample(){}; // error.
    final class Sample {}

- anonim sınıf yazımı aynı zamanda bir bildirimdir. Bu yüzden anonim sınıfı yazarken ilgili
  taban sınıfın fonksiyonları anonim sınıf içerisinde override edilebilir.

   Sample s = new Sample() {
                public void foo()
                {
                    sout("Anonim class");
                }
              };

  class Sample {
    public void foo(){}
  }

--------------------------------------------------------------------------------------------------------------
                                                12.04.2020
--------------------------------------------------------------------------------------------------------------

- abstract sınıftan türetilmiş anonim sınıflar
    - Anonim sınıflar abstract sınıflardan türetilirse, abstract sınıfın tüm abstract metodları
      override edilmek zorundadır. Override edilmemesi halinde error oluşur.

    - Abstract türünden referans'lar genellikle bir fonksiyonun parametre değişkeni olarak kullanılır.

- anonim sınıflar farklı paketteki bir sınıf türünden isim ile yaratılıyor  ise bu sınıfların protected bölümüne
  erişebilir.

- anonim sınıflar da yerel sınıflarda olduğu gibi kendisinden önce bildirilen yerel değişkenleri veya
  parametre değişkenlerini yakalayabilirler. Bu durumda yine final olmayan bir yerel değişken veya parametre değişkeni
  için effectively final kuralları geçerlidir.

- callback : Ne yapılacağını dışarıdan alacağımız(Yani bir bakıma functor sınıflardır.) değişkenlerdir.

- callback tarzı sınıflar genel olarak belirli periodlar ile çalışan metodlara geçilen metodlardır.  Böyle metodlara
  timer metodlar denir.

--- Timer class ----
    - Timer işlemlerinde kullanılan en temel sınıflardan biridir.
    - Kursta şu anda saddece default ctor'u kullanılacaktır.
    - sınıfın scheduleXXX metorları ile ayrı bir akış oluşturulur. ve girilen perioda göre TimerTask referansı
      ile aldığı türe ilişkin run metodu çağırılır. TimerTask parametresine, TimerTask türünden anonim bir sınıf
      geçilebilir.


--- Timeunit enum'ı -----
    - Timeunit enum'ı girilien değerin hangi saniye cinsinden olduğunu belirtir.(1,TimeUnit.HOURS) // Burada girilen 1
      sayısı saat cinsinden verilmiştir. yani kullanıcıya TimerTask için milliseconds türünden değil saat, saniye, dakika
      cinsinden istenildiği gibi verme gösterme imkanı sunulmuştur.



--------------------------------------------------------------------------------------------------------------
                                            19.04.2020
--------------------------------------------------------------------------------------------------------------

- anonim sınıflar sadece abstract sınıflardan değil ayrıca somut türlerden türetilebilir.

- anoninm sınıflara non-static initializer yazılabilir. non-static initializer kullanılarak nesnelere değer verilebilir.
- Burada eğer non-static initializer taban sınıfın nesnelerine erişiyor ise bu nesnelere ilk değer veriyormuş gibi
  kullanılabilir.

- Point p = new Point(){ {x = 10; y = 20;} }; // şeklinde bir kod sanki Point türüne kullanıcı tarafından istenilen bir
  değer atanıyormuş.


- anonoim sınıf herhangi bir  sınıftan türetiliyor ise hem yeni bir sınıf bildirimi hemde nesne yaratma işlemidir.
- anonim interface ise bir interface bildirimi ve implementasyonudur.

- teknik olarak ya bir interface'i implemente edecek yada anonim bir sınıftan türetilecektir.

- anonim bir sınıf birden fazla interface'i implemente edecek şeklinde yazılamaz.

- Bir metodun başka bir çağıracağı metodu yapabilmesine high  order function denir(Ne yapacaığını dışarıdan almak).
  Timer sınıfının schedule metodu tamamen böyledir(Ne yapacağını TimerTask interface'inden alıyoruz.).

- Java da doğrudan bir metod verilmesi gibi bir durum yoktur.



--------------------------------------------------------------------------------------------------------------
                                            Lambda ifadeleri(Lamba expressions)
--------------------------------------------------------------------------------------------------------------


- içerisinde bir ve yalnız bir tane abstract metod olan interface'lere fonksiyonel interface denir.
    interface IX {
        void foo();
        default void bar()
        {
        }
    } // IX interface'i bir functional interface'dir. Çünkü bar metotu abstract değildir.

- Java 8 ile birlikte eklenmiştir.

--- Lambda ifadelerinin genel biçimi ------

- Lambda ifadeleri uygulanabilecek her yerde uygulanılmalıdır(always applicable).

    1- (değişken_listesi) -> ifade
    2- (değişken listesi) -> {...}
    3- değişken -> ifade
    4- değişken -> {...}
    5- () -> ifade
    6- () -> {}
    7- (<tür değişken listesi>) -> ifade
    8- (<tür değişken listesi>) -> {}

- Yukarıdaki 8 yazım şekli lamba ifadelerinin genel implementasyon biçimidir.

- Lambda ifadeleri ancak ve ancak uygun fonksiyonel arayüz(interface) referanslarına atanabilir. Arayüz dışında herhangi
  bir referansa yada fonksiyonel olmayan arayüz referanslarına atanamaz(örneğin abstract bir sınıf referansı, yada
  fonksiyonel  olmayan bir interface referansına atanamaz.).

- Lambda ifadesi ile fonksiyonel bir arayüzün o bir tane olan fonksiyonunu override etmek yerine(Burada kastedilen
  aşağıda implemente edilmiştir.) onun yerine geçen kodu kısa bir biçimde yazmış oluruz.

--------------------------------------------------------------------------------------------------------------
                                            25.04.2020
--------------------------------------------------------------------------------------------------------------

- Lambda ifadeleri bir ifade olduğu için bir türleri vardır.

- Lambda ifadesi tam olarak atandığı fonksiyonel arayüz referansının ilgili abstract metodunu override edilmiş
  hali gibidir.

- Fonksiyonel arayüzler sanki  metot tutabilen bir türmüş gibi davranan arayüzlerdir. Lambda'lar da sanki
  bu fonksiyon türüymüş ve fonksiyonel arayüze atanan bir tür gibidir.


- callback kavramı tam olarak bir programa ne yapacağımızı bizim vermemizdir. Diyebiliriz. Burada yazılan kütüphane bir
  callback ister ve ona geçilen callback'i çağırır.

- Java da ki bu fonksiyonel arayüzler aynı bir function pointer gibi davranırlar
- lambda ifadelerinde oktan öncesi kısım bize parametrik yapıyı gösterir.

- Lambda ifadeleri için derleyici arka planda başka bir sınıf yad anonim sınıf oluşturmaz.

- Lambda ifadelerine ilişkin olarak, ilgili ifade bir çok kez yeniden kullanılabilir.

- Lambda ifadeleri uygun fonksiyonel inteface'lere atanabilir. Lambda ifadeleri tür çıkarımı yapılacak ise
  tür çıkarımını kendisi yapacaktır.

- Lambda ifadesinde tek bir değişken var ise tür tarafına yazılan parantezlere gerek yoktur.
  IIntUnaryOperator op = a -> a * a; // burada oktan önceki yer bir bildirim gibidir. Burada sadece a değişkeni
  bildirilmiştir.
  IIntBinaryOperator op = (a, b) -> a + b; // burada a ve b değişkenleri bildirilmiştir.

- Eğer birden fazla işlem yapılacak ise method gövdesi biçiminde yazılabilirler.
     IIntBinaryOperator op = (a, b) -> {
        sout(a + " " + b);
        return a + b;
     }

- ilgili functional interface generic bildirilse bile tür çıkarımını kendisi yapabilir.
    IBinaryOperator<Integer> opInt = (a, b) -> a + b;
    IBinaryOperator<String> opStr = (name, surname) -> name + " " + surname;

interface IBinaryOperator<T> {
    T apply(T a, T b);
}

- anonim sınıflar lambda ifadelerinin yerine geçerken, lamba ifadeleri anonim sınıflar yerine kullanılamaz.
  Kullanabilen her yerde lamba ifadeleri kullanılabilir.

- Lambda ifadelerinin parametre değişkenleri yerel değişken kabul edilir ve ilgili Lambda ifadesi boyunca görülebilir.

- Lambda ifadelerinde bildirilen bir yerel değişken ile aynı isimde başka bir yerel değişken o scope boyunca yeniden bildirilemez.

- Lambda ifadeleri de yerel ve anonim sınıflar gibi bulunduğu kod bloğundaki bir değişkeni yakalayabilir. Burada
  yakalanan değişken değiştirilemez.

- Fonksiyonel arayüzler generic interface'ler ile kullanılada bilir.
  Basit bir convert işlemi

  IFunction  s2l = a -> a.length();
  s2l.apply("ankara");//6 çıkar
  interface IFunction<T, R> {
    R apply(T t);
  }

- lambda parametreleri içerisinde tür yada var keywordu kullanılabilir. Ancak tür kullanılse bile lambda ifadelerinin atanacağı
  referans var keyword'u ile belirtilemez.

- Java 11 ile parametre tür dğeişkenleri var ile bildirilebilir.
    IBinaryOperator binaryOperator(var a, var b) -> a + b; // since java 11;
    interface IBinaryOperator {
        int apply(int a, int b);
    }

- fonksiyonel arayüz referanslarına eğer elimizde parametrik yapısı tam uyumlu bir reference var ise bu metot ::
  (çözünürlük) operatörü ile doğrudan atanabilir.
- metod reference'lar non-static metodlar ile de yapılabilir.Ortada bir refence olması gerekir.



- metot reference'ın genel biçimi statik metodlar için <class Name>::function_name;//şeklindedir.

- metot reference'ın non-static metotlar için genel biçimi ise <reference>::function_name;

- Metod reference'ları non-static fonksiyonları(Örneğin String length fonksiyonu), sanki bir statik metotmuş gibi
  kullanılabilir. Bu tammen run-time'da static fonksiyonların non-static fonksiyonlara çevrilmesi ile alakalıdır.

- <Sınıf ismi>::new sentaksı ctor çağrılmasını sağlayan sentaksıdır. Bu durumda interface'in ilgili sınıf türüne dönen
  bir tan abstract metodu olmalıdır. Ayrıca sınıfın da bu abstract metodun parametrik yapısına uygun bir ctor'u
  bulunmalıdır. Burada ctor parametresiz ise parametresiz bir abstract metod bulunmalıdır.

- ctor parametreli yazılmış ise ona göre de interface'in  parametreli yazılmış olması gerekir. Bizde Yazacağımızı yapıyı
  buna göre düzenlemeliyiz.

--------------------------------------------------------------------------------------------------------------
                                            26.04.2020
--------------------------------------------------------------------------------------------------------------


-------- Metot referans çeşitleri -------
- Pratikte kullanılan 4 çeşit metot referans vardır.
    1-) static metot referansları(reference to a static metod)
    2-) Bir nesneye ilişkin non-static metotun reference(reference to an instance(non-static) method of particular object)
    3-) Bir türe ilişkin  non-static metot referansı (reference to an instance(non-static) metot of any object of particular type)
    4-) Ctor referansı(Reference to a ctor)

- Java da generic sınıfların wrapper sınıflar için kullanılabilen bütün interface'lerin ayrıca primitive türler için
  ayrıca temel türler için olan kısmı ayrıca yapılır.



----- Java'nın function paketi ------

- java.util paketi altındadır.

- predicate interface'ler
    - geri dönüş değeri boolean olan abstract fonksiyonu test ile isimlendirilmiş, veriyi alıp test eden interface'dir.

- Supplier grupları
    - Parametre almadan tür döndüren sınıflardır(Random sınıfının nextInt metodu için kullanılabilir.).

- callback : bir metod dışarıdan hangi metodu çağıracağını alırsa böyle parametrelere call back denir. Bu tarz metodlar
  high order metodlar denir.

- function paketinin detaylarını değil daha çok kullanımını göz önünde bulundurmalıyız.

- function sınıfının bütün interface'lerini ezberlemek değil, kullanarak akılda kalması sağlanmalıdır.

----- optional sınıfı -----

- Java 8 ile eklenmiştir, Generic bir sınıftır. Bu tarz türlere nullable type'lar denir.

- Optional türü bir nesne var ise kullanılıp, eğer nesne yok ise  herhangi bir şey yapmayacaktır. Optinal sınıfı ortada
  bir işi exception olmadan halletmenin yöntemidir.

------------------------------------------------------------------------------------------------------------------------
                                            02.05.2020
------------------------------------------------------------------------------------------------------------------------

- CommandPromptApp uygulaması yapıldı

------------------------------------------------------------------------------------------------------------------------
                                            03.05.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            Optional sınıfı
------------------------------------------------------------------------------------------------------------------------

- Sınıfın static empty metodu ile boş bir optional nesnesi elde edilir.

- Optional sınıfının of metodu ile bir bilgi Optional türüne dönüştürülür. Java'nın x. versiyonundan sonra valueOf
  metodları of olarak isimlendirilmeye başlamıştır. Optional.of(T t)

- Sınıfın isPresent metodu ile bir optional nesnesinin dolu olup olmadığını test ederiz. isEmpty ilede argüman geçilen
  nesnenin boş olup olmadığı test edilir.

- Sınıfın static ofNullable fonksiyonuna geçilen parametre null ise empty bir optional değil ise dolu optional referansı
  döndürür.

- Optional içerisindeki isPresent ve empty fonksiyonları bir flag ile kontrol edilerek yapılır.

- sınıfın non-static get fonksiyonu ilgili optional referansın sarmaladığı değeri geri döndürür.

- Optional sınıfının ctor'u private'tır.

- sınıfın ofNullable metodu aldığı parametre null ise boş null değil ise dolu optional referansı döndürür.

- bunu of metodu ile yapamayız, of metoduna null geçmek NullPointerException fırlatılmasına sebep olur.

- orElse metodu eğer kullanılan referans boş ise geçilen default değeri, dolu ise içerisindekini verecektir.
  orElse metodunun karşılığı aşağıdaki gibidir
  Optional<String> r  = Optional.of("ankara");
    String s = r.isPresent() ? r.get() : "ankara";

- orElseThrow metodu eğer verilen referans boş ise bir NoSuchElementException throw edilecektir.
  bir tane overload'ı vardır.

- ifPresent'in Consumer<? super T> action parametreli metodu eğer verilen optional referansı dolu ise yapılacka işi gösterir.

- Consumer interface'i kendisine gönderilen parametre ile bir iş yapıp void değeri döndürür.

- filter fonksiyonu argüman olarak geçilen predicate sağlanıyor ise, bu predicate' sağlayanlar için
  ilgili referansı, sağlanmıyor ise empty Optipnal döner.

- map fonksiyonu : parametresi Function interface'i türündendir. Bir optional sınıfından başka bir optional elde etmemizi
  sağlar. map empty bir optional referansı ile çağırılırsa empty Optional türüne döner.

- Function(BiFunction da dahil) açılımına göre verilen paramatrelere göre farklı bir değer üretir.

- Optional sınıfının kullanım çeşitleri
    1-) fonksiyonun geri dönüş değeri
    2-) fonksiyon parametresi (az rastlanmaktadır.)
    3-) Sınıfların veri elemanları da optional olabilir.
------------------------------------------------------------------------------------------------------------------------
                                            09.05.2020
------------------------------------------------------------------------------------------------------------------------


- API nedir ?
    - Aslında aşağı seviyeli kullanılan bir kavramdır.
    - İşin detaylarını bize göstermeden kullanıma odaklı kullanılan sınıflar(örneğin yazdığımız DateTime sınıfı).

------------------------------------------------------------------------------------------------------------------------
                                            LocalDate, LocalTime ve LocalDateTime sınıfı
------------------------------------------------------------------------------------------------------------------------

- Java 8 ile birlikte bir LocalDate, LocalDate ve LocalDateTime API'leri eklenmiştir. Immutable  sınıflardır.

- LocalDate sınıfının ctor'u yoktur. of metodu ile nesne yaratılır. getter'ları ayrı ayrı yazılmıştır. setter'ları yoktur
- Month enumları vardır, ayrıca int'e dönen month değerleri doğru tarihleri döner.
- Geçerlilik kontrollerini yaparlar.
- now metodu ilgili günü döndürür.
- isAfter ve isBefore metodları vardır.

- sınıfın plusXXX metodları ve minusXXX metodları ilgili tarihe ekleme ve çıkarma yapabilir.

- LocalTime sınıfının atDate fonksiyonu parametresine geçirilen LocalDate göre bir LocalDateTime nesnesi döner.
- LocalDate sınıfının atTime fonksiyonu parametresine geçirilen LocalTime göre bir LocalDateTime nesnesi döner.

- ChronoUnit enum'ı
    - belirli  olan(seconds,days,months) gibi enum constant'larına sahip
    - between adlı metodu ile verilen iki tarih arasındaki farkı ilgili enum sabitine çevirir.
        ChronoUnit.DAYS.between(m_birthDate,LocalDate.now());//iki tarih arasındaki gün farkını bulur


- Void sınıfı işlen
------------------------------------------------------------------------------------------------------------------------
                                            10.05.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            assert işlemi
------------------------------------------------------------------------------------------------------------------------

- assert expression'ının kullanımı
    assert [boolean ifade]  [: void olmayan ifade]
    assert true; // bu kod doğrudur, eğer bir belirli bir sonuç basılmak istenirse aşağıdaki gibi yapılmalıdır
    assert true : "Assert edildi";

- eğer ki assert deyimine ilişkin ifade true ise akış assertten devam eder false ise AssertionError nesnesi fırlatılır.
  void olmayan ifade de burada exception'a ilişkin mesajı temsil eder.
- dile özgü bazı testleri çok anlaşılır bir şekilde yapılmasını sağlar.

- assert expression'ı program ancak ve ancak -ea yada -enableassertions modunda çalıştırıldığı zaman  çalışan
  bir expression'dır.

- assert işlemi derlemeye yönelik bir işlem değildir. runtime da yapılacak bir işlemdir. Ancak bu kullanıcıyı
  ilgilendiren bir işlemde değildir. Bu kodu yazan kişinin kendisinin yazdığı kodu kontrol edilmesi için kullanılır.

- assert işleminde eğer fonksiyon çağrılıyor ise dikkatli olunması gerekir. Eğer ki -ea flagı girilmemiş ise ve ilgili
  fonksiyonun her türlü çağrılması isteniyor ise ilgili fonksiyon çağrısını daha önceden yapmalıyız.


------------------------------------------------------------------------------------------------------------------------
                                            Annotation(Ek açıklama)
------------------------------------------------------------------------------------------------------------------------

- Java 5 ile eklenmiştir.
- bir annotation bildirimi @interface bitişik biçiminde yapılır.
    @interface MyAnnotation {
    }

- annotation nerelere konulabilir?
    1- Bir sınıfın başına
    2- Bir metoda
    3- Bir veri elemanına
    4- bir metodun parametresine(Java 8 ile birlikte eklenmiştir.)

    @MyAnnotation
    class MyClass {
        @MyAnnotation
        private int m_val;

        @MyAnnotation
        public void foo(@MyAnnotation int x)
        {
        }
    }
    @interface MyAnnotation {
    }


- Bir annotation içerisinde geri dönüş değeri olan adeta metot bildirimi gibi property'ler bildirebilir.
  Bunlar metod değildir. Bu yüzden herhangi bir parametre bildirilemez.
    @interface MyAnnotation{
        String value(); // bu propertyler default anahtar sözcüğü ile de bildirilebilir
        String value() default "Any";
    }

- Bu property'lerden en az bir tane bile  default anahtar sözcüğü ile belirtilmemiş ise  annotation doğrudan
  kullanılamaz. İlgili property'ye bir atama yapılmalıdır. Eğer hepsi default anahtar sözcüğü ile belirtilmiş ise
  annotation doğrudan kullanılabilir.

   @MyAnnotation
   class Myclass {
       @MyAnnotation(value = "member variable")
       private int x;

       @MyAnnotation(value = "method")
       public void foo(@MyAnnotation(value = "parameter") int x)

   }
   @interface MyAnnotation {
       String value() default "";
       String value2() default "";
   }
   //örnekte ki  value2'nin default'ı kaldırılır ise kodlar error verir.

- Bu default sözcüğünün 3. kullanım şeklidir.
    1-) switch
    2-) interface'lerin default fonksiyonları
    3-) annotation da property


- Bir annotation'ın nerelere konulabileceğini Target annotation'ı ile bildirilebilir.
  Target annotation'ı bir annotation'ının nereye konulacağını belirtir.
  Bu annotation'ın value isimli bir attribute'ı vardır. Bu attribute ElementType enum'ı türünden bir dizi alır.

    @Target(value = {ElementType.TYPE, ElementType.MODULE})
    @interface Entity {

    }
- annotation'larda daha çok varolan annotationlar kullanılacaktır.
- annotation metadata, işaret veya dipnot anlamında kullanılabilir.

- Annotation kendisinden hemen sonra gelen uygulandığı elemanı kapsar.
   @ColumnInfo
   private String m_citizienId,name;// burada ikisini de kapsar.


- annotation 3 şekilde kullanılabilir. Buna Retention denir. Retention bir annotation'ın nasıl kullanabileceğini belirtir.
    1-) runtime da(RetentionPolicy.RUNTIME) // Annotation'ın runtime da kullanabileceğini gösterir.
    2-) class işaretleyebilir. // (RetentionPolicy.CLASS)
    3-) source işaratleyebilir.//(RetentionPolicy.SOURCE)Derleyiciye daha derlemede yapmadan önce yapılacak işlemler.

- @Override annotation'ın retention türü source'dur.(Kullanmamız gereken her yerde kullanılmalıdır.).
  target'ı sadece metotlardır.

- Override annotation'ı bir sınıftan türetilmiş ve override edilmiş metotlar için kullanılır.

------------------------------------------------------------------------------------------------------------------------
                                            19.05.2020
------------------------------------------------------------------------------------------------------------------------

- Annotation'ların elemanın ismi value ise ve işaretleme sırasında yalnızca value elemanına değer verilecekse
  value =  biçiminde yazılmasına gerek yoktur(Bu durum value ismine özgü bir kavramdır.). Eğer value elemanı dışındaki
  elemanlara da değer verilecek ise value = biçiminde yapılması gerekir.

- Deprecated annotation'ı bir elemanın(metot, class vs.) deprecated olarak işaretlenmesi için kullanılır.
- Deprecated annotation'ı bir runtime annotation'dır. Neredeyse bütün türlere uygulanabilir(Annotation'lar hariç).

- Java 9'dan önce bu annotation'ın herhangi bir property'si yoktur.

- Java 9 ile beraber bu annotationa iki tane property eklendi.Bunlardan biri String türünden since, diğeri de
  boolean türünden forRemoval'dır. forRemoval takip ettiği şeyin ileri de silinip silinmeyeceğini belirtir.
  since ise versiyon belirtmek için kullanılır.

- @Inherited annotation'ı da vardır. Eğer taban sınıf bir annotation'a sahipse normalde bu sınıftan türetilen bir sınıf
  ilgili  annotation'a sahip değildir. Ancak bu annotatiton @Inherited annotation'ı ile işaretlenir ise
  türemiş sınıflarda ilgili annotation'a sahip olur. Target'ı sadece ve sadece annotation'dır.

- FunctionalInterface annotation'ı(Java 8 ile eklenmiştir.)
    - Önceden oluşturulmuş bir interface'in fonksiyonel olup olmadığını ilişkin işaret koymak amaçlı kullanılabilir.
    - Bildilendirme amaçlı bir annotation'dır. Türü RunTime'dır.
    - Bu annotation ile işaretlenmiş bir arayüz içerisinde bir ve yalnız bir tane abstract metot olmalıdır. Aksi
      durumda error oluşur.

- SuppressWarnings annotation'ı(warningleri görmezden gel)
    - Aldığı value değerine ilişkin warning'i görmezden gelir. Örneğin CSDArrayList'e ki Object dizi türünden ilgili
      T türüne dönüşümün yapılmasında kullanılmalıdır. Bu annotation kullanılırken programcının emin olması gerekir.
    - Çünkü derleyicinin verdiği hatalar önemlidirler ve dikkate alınmadırlar. Eğer programcı emin ise bu annotation'ı
      kullanmalıdır.


- Java da Generic sınıflar   invariant olduğundan aşağıdaki kod errordur. Generic sınıfları covariant yapmak için
  ? extends sentaksı kullanılır.
    ArrayList<Number> ss = new ArrayList<Integer>();//error
    ArrayList<? extends Number> ss = new ArrayList<Integer>();//covariant haline getirilmiştir. upcasting tarzı durumlar
    için ? extends sentaksı ile kullanılmalıdır(Burada denilmek istenilen Number veya Number'dan türemiş olmalıdır demek
    istenir. Yani bir üst kısıt getirilmiştir. Dikkat bu referansa Integer, Double, BigDecimal, BigInteger sınıfları
    atanabailir.).

- Javada covariant bir generic sınıf yazılamaz. Sınıflar invariant olarak yazılabilir.

- generic bir sınıfa bir kısıt getirilmek istenirse bu kısıt bir sınıftan türetilmek yada bir interface'i implemente
  etmek olacak ise ikisi içinde extends keywordu ile yapılır(Dikkat interface için implements kullanılmaz.).
    class A<T extends <Bir_tür>

- Generic bir sınıfı contravariant yapmak(açılımları downcasting'e uygun hale getirmek için) ? super sentaksı
  kullanılır.
    ArrayList<? super Integer> arrayList; //burada bu arrayList ancak ve ancak Integer veya Integer'a parent class
    larından bir sınıf atanabilir. atanabilir.
    ArrayList<? super Integer> arrayList = new ArrayList<Number>();

- invariant durumlar : atamanın doğrudan yapılabileceği (Java da default generic türü invarant'tır.)

- covariant durumlar : generic türler için atamanın bir upcasting işlemi gibi ypaılabilmesi
    (bir üst sınır verme işlemidir. ? extends [Type] sentaksı ile yapılır. Type'dan türemiş sınıflar atanabilir.)

- contravariant durumlar : generic türler için atamanın bir downcasting işlemi gibi ypaılabilmesi
    (Bir alt sınır verme işlemidir. ? super [Type] sentaksı ile yapılır. Type'ın super class'ları atanabilir.)

- covariant bir generic referans'a ? extends ile belirtilen type sınıfının metodları veya o sınıfın super class'larının
  metodları  kullanılabilir. Bunun dışındaki metodlar kullanılamaz. Örneğin ilgili type Number ise sadece Number
  ve Object sınıfının fonksiyonları kullanılabilir.

- contravariant bir generic referans'a ancak ve ancak ? super sentaksı ile belirtilen sınıf türünden veya bu sınıftan
  türemiş bir sınıftan ekleme yapılabilir. Bunun dışındaki bir türden ekleme yapılamaz. Örneğin iligli type Object ise
  bütün türler eklenebilir. Ancak ilgili type Integer ise sadece Integer sınıfı türünden bir tür eklenebilir.


------------------------------------------------------------------------------------------------------------------------
                                            REFLECTION
------------------------------------------------------------------------------------------------------------------------

- Çalışma zamanı sırasında bir türe ilişkin bilgilere(metadatalara) bakmaktır.

- metadata : bir kavramla ilişkin bilgilere(Bir sınıfın veri elemanları) erişmektir.

- Java da programın çalışma zamanı sırasında her tür için(temel türler dahil) bir Class nesnesi yaratır.
  Bu .class dosyası değildir. Bir Class sınıfıdır.

- Her tür için bir tane Class nesnesi vardır(Singleton).

- Class sınıfı generic bir sınıf olup bir türe ilişkin bilgileri içeren bir sınıftır.

- Reflection işlemleri Class sınıfı ile gerçekleşir. Türün Class nesnesini üretmek için <tür>.class sentaksı kulalnılır.

- Eğer ilgili sınıf bir primitive tür ise aşağıdaki gibi elde edilmelidir. Bu sentaks daki soru işareti any type
  anlamında kullanılır.
    Class<?> clsInt = int.class;

- Eğer ilgili sınıf bir referans türü ise
  Class <Sample> clsSample = Sample.class;
  Class <String > clsString = String.class;

- Class sınıfının static forName metodu ile türü String olarak elde etmemizi sağlar.
    Class<?> clsSample = Class.forName("org.csystem.app.Sample"); //ilgili paketteki Sample sınıfını getir.
    Dikkat eğer sınıf bulunamaz ise checked exception olan ClassNotFoundException nesnesi fırlatılır.

- Class sınıfının getName fonksiyonu ilgili sınıfın ismini nitelenmiş bir şekilde verir.

- Object sınıfının getClass metodu ile referansın dinamik türüne ilişkin Class referansı elde edilir.

- Class sınıfının getDeclaredXXX(Methods, Fields ...) metodu ile türe ilişkin elemanlarına erişim belirleyiciden bağımsız
  erişilebilir. Bu metod taban sınıfın metoduna erişemez.

- Sınıfın getXXX(Method,Field,Annotation) metodu ile türe ilişkin sınıfın  ve taban sınıflarının yalnızca public bölümündeki
  elemanlarına erişilir(taban sınıfların sadece public bölümüne  erişilir. protected bölümüne erişilemez.).


------------------------------------------------------------------------------------------------------------------------
                                            23.05.2020
------------------------------------------------------------------------------------------------------------------------
- Reflection için kullanılan sınıfın herhangi bir ctor'una erişim Class sınıfının getDeclaredConstructor metodu ile
  sağlanabilir. Bu metod generic bir sınıf olan Contructor sınıfını geri döndürür. Eğer bulunamaz ise
  NoSuchMethodException hatası fırlatır.
    Class<?> cls = Class.forName("org.csystem.app.Sample"); // checked bir exception fırlatır.
    cls.getDeclaredConstructor();// eğer parametreli bir ctor alınmak istenirse ilgili ctor'un parametre'lerinin
    class nesneleri verilmelidir.
    Eğer Sample sınıfının int, double parametrelerine sahip bir ctor'u var ise aşağıdaki gibi yazılır.
    Constructor<?> intDoubleCtor = cls.getDeclaredConstructor(int.class, double.class);
    intDoubleCtor.setAccesible(true); // Eğer ki ctor private bildirilmiş ise bu kod yazılmadan çağrılması errordur.
    intDoubleCtor.newInstance();// eğerki constructor erişilebilir ise bu kodlar çağırılır. Eğerki erişilebilir

- Class sınıfının getDeclaredXXX(Method, Field ...) String parametreli methodları sınıfın erişim belirleyicisinden
  bağımsız ilgili  elemanına erişmemizi sağlar. Eğer verilen String parametresine uygun bir eleman bulunamaz
  ise checked exception throw eder.
- Class sınıfının getXXX(Method, Field ...) String parametreli methodları ilgili türün ve taban sınıflarının public
  bölümündeki elemanına erişmemizi sağlar. Eğer verilen String parametresine uygun bir eleman bulunamaz  ise CHECKED
  exception throw eder.

- Yukarıdaki iki durum içinde  Erişilen elemana göre(eğer eleman Method ise Method sınıfı, field ise Field) o sınıf
  türünden nesne elde edilir.
    Class<?> clsSample = Class.forName("org.csystem.app.App");
    Class<Sample> clsSample = Sample.class;//Eğer tür biliniyor iseşeklinde yazılabilir.
    Constructor<?> ctor = clsSample.getDeclaredConstructors(/*Parametrik yapıya uygun class nesnesi verilmelidir.*/);
    Constructor<Sample> intCtor = clsSample.getDeclaredConstructors(int.class);//int parametreli ctor istenmiştir.
    Field field = clsSample.getDeclaredField("x");//eğer  ilgili method yok ise checked error fırlatılır.
    Method method = clsSample.getDecleradMethod("getX", int.class, double.class);//eğer ki sınıfın int ve double
    parametreli getX methodu var ise elde edilir yoksa error oluşur.
- Elde edilen bir Method, Field yada Ctor .... sınıfın içinde private bildirilmiş ise ve kullanılması gerekiyor ise
  bu sınıfların setAccessilbe(true); şeklinde çağrılması gerekmektedir. işlem bittikten sonra setAccessible yeniden false
  yapılmalıdır.

- Elde edilen tür bir ctor ise ve yeni bir nesne yaratılmak istenir ise tür Constructor sınıfının non-static ctor'ı sınıf
  any Type ile açılmış(Yani Constructor<?>) ise new Instance methodu geriye Object döndürür. Type Cast yapılması zorunludur.

- Elde edilen tür bir Method ise ve sınıfın ilgili metodu çağrılmak istenir ise Method sınıfının non-static invoke metodu
  ile bu işlem yapılır. Ne olursa olsun non-static bir method için ortada bir nesne olmak zorundadır.
  invoke methodunun birinci parametresi ilgili sınıf türü ne ise o sınıf türünden bir referans ister. Eğer ki method
  static bir method ise bu parametreye null geçilebilir.


- Singleton design pattern'i Reflection ile delinebilir. Ancak enum türünden reflection ile elde edilemez. Enum türünden
  sadece enum sabitlerinden kaç tane  var ise program boyunca o sayı da nesne vardır.

- constructor kodları ara koda yazılırken init ismi ile yazılır.

- @Deprecated annotation'ı Inherited bir annotation değildir.

- DynamicLoadingApp uygulaması yapıldı.
    - Uygulama çalışırken SampleClasses modülündeki .class dosyaları  uygulamanın çalıştığı modüle( yani out'un altındaki
      production'ın altındaki 004-SampleDynamicLoading modülüne eklendi);

- GameObject örneği yapıldı(Dikkatlice incelenmesi gereken bir örnektir).

- Method sınıfının invoke methodu
    1. parametresi -> ilgili metodun hangi referans ile çağıralacağı(static bir metot ise null geçilebilir.)
    2. parametresi -> ise Object ... args'dır. Metota geçilecek argümanlar içindir
    m.invoke(gameObject,other); // gameObject.onCollision(other);



------------------------------------------------------------------------------------------------------------------------
                                            24.05.2020
------------------------------------------------------------------------------------------------------------------------

- Generic'ler de Programlama da 3 farklı yaklaşım vardır
    1- C++'da ki gibi(Derleyici compile time'da kod yazar)
    2- C# da ise her açılım için farklı bir tür vardır(Derleyici ayrıca bir kod yazmaz).
    3- Java da ise her açılım için tek bir tür vardır().

- Generic sınıflar'ın tek bir tür olduğunu ilgili sınıfın farklı açılımlar için getClass fonksiyonlarını çağırıp
  karşılaştırma yapılarak ispatlanabilir.

------------------------------------------------------------------------------------------------------------------------
                                            Collection lara yönelik interface'ler
------------------------------------------------------------------------------------------------------------------------

--- iterable interface'i
- Java da tüm collection sınıfların başında yer alan özel bir interface vardır. Bu interface'in ismi iterable'dır.

- Herhangi bir veri yapısının datalarının nasıl tutulduğundan BAĞIMSIZ OLARAK dolaşabilmeye iterator pattern'i denir.
  (C++'ın STL'i tamamen iterator kalıbına dayalıdır.)

- iterable olmak iterator biçiminde kullanılabilir olmak anlamına gelmektedir. Bu interface java 5 ile eklenen generic
  bir interface'dir. Java 5 ile beraber for-each döngü deyimi de eklenmiştir.

- Bir sınıfın foreach döngü deyimi ile dolaşılabilir olması için sınıfın iterable interface'ini desteklemesi gerekir.

- iterable sınıfının yalnızca bir adet abstract  metodu vardır. Metodun ismi iterator'dur. parametrik yapısı aşağıdaki
  gibidir.
    Iterable<T> iterator();

- Iterator interface'i(Java 1.2) Iterable interface'inden  daha önce implemente edilmiş generic  bir interface'dir.

- Iterator<E> interface'inin iki tane abstract metodu vardır.Bunun dışında metodları vardır.
    boolean hasNext();
    E next();

- Java 8'den önce üç tane abstract metodu vardı.
    void remove(); //3. fonksiyon remove idi.

- Java 5'den önce yani iterable interface'inden önce(Yani foreach döngüsü yokken) iterator dolaşımı şu şekilde
  yapılmaktaydı.

  ArrayList<Integer> list = new ArrayList();
   Iterator<Integer> iter = list.iterator(); // iterable'dan önce Iterator döndüren iterator fonksiyonu vardı.
   while(s.hasNext()) {
        int val = s.next();
   }

- foreach always applicable'dır.

- foreach kodunun karşılığı tam karşılığı şağıdaki gibidir.
    ArrayList<Integer> list = new ArrayList();
   for(int val : list) {
        System.out.printf("%d ", val);
   }

   {
       Iterator<Integer> iter = list.iterator();

       while (iter.hasNext()) {
           int val = iter.next();

           System.out.printf("%d ", val);
       }
   }

- burada hasNext() metodu bir sonraki elemanın olup olmadığını kontrol eden metoddur.

- next() metodu ise bir sonraki elemanı geri döndüren metoddur(Eğer eleman yoksa ve çağrılmış ise NoSuchElementException
  fırlatılır.). next fonksiyonu aynı zamanda iterator'de ilerlemeyi sağlayan fonksiyondur.Nasıl yapıldığı o kodu
  implemente eden kod belirler(Örneğin yazılan IntRange'de belirtilmiştir).

- Java'da Iterable'dan sonra Iterable'dan türetilmiş generic Collectin arayüzü vardır. Collection'ının da bir iterator
  metodu vardır. Collection'ın iterator dışında bir çok abstract metodu vardır.

- NOT : java'da iterable olabilmek için sınıfın iterable interface'ini implemente etmek yada iterable türetilmiş bir
  interface'i implemente etmek zorunludur.
- Collection'dan türetilmiş
    List interface'ini implemente eden Collection sınıflar (ArrayList, Vector, LinkedList(bağlı liste))
        Bu collection'ların aralarında öncelik sonralık ilişkisi vardır.

    Set interface'ini implemente eden Collection sınıflar (Küme Collection'larıdır.)
        1- Bu collection'lar içinde sıranın önemi yoktur(İçerisinde sıranın önemi olanlar vardır.).
        2- Kümenin elemanlarının her biri bir tanedir.

    Queue interface'ini implemente eden Collection sınıflar

- Collection'dan türetilmemiş Map interface'i vardır.
    - Map'i destekleyen sınıflara sözlük tarzı collection'lar denir.
    - Map'ten türetilmiş sınıflar iterable DEĞİLDİR(Çünkü collection'dan yada iterable'dan türetilmemiştir).
