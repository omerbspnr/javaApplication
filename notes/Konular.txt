- Java Uygulama kursu -
--------------------------------------------------------------------------------------------------------------
                                            01.03.2020
--------------------------------------------------------------------------------------------------------------

- Bir algoritmanın karmaşıklığı iki şeye bağlıdır.
    - Hız
    - Kaynak kullanımı


- Big O notation
    - Büyük O harfinin içerisine n'e bağlı bir denklem yazılır.
      O(1)// Sabit karmaşıklık // döngü yok anlamında, Örneğin dizi erişimi
      O(n) // lineer(doğrusal) karmaşıklık // tek döngü içeren algoritma // dizinin elemanları toplamı
      O(n ^ 2) // Karesel karmaşıklık iç içe döngü içeren(iki tane) algoritma // matrisin  elemanları toplamı
      O(n ^ 3) // Küpsel karmaşıklık
--------------------------------------------------------------------------------------------------------------
                                            StrinBuilder class
--------------------------------------------------------------------------------------------------------------

- String sınıfı immutable(içerisindeki veri değiştirimez) özelliğe sahip iken,
  StringBuilder sınıfının içerisindeki veri değiştirilebilir.

- String sınıfı türünden runtime'da atanan(Örneğin klavyeden girilen yada new operatörü ile oluşturaln) aynı
  yazılar birbirinden farklı adresler üretir.
    - Yukarıdaki olayda derleyicinin olayın içinde olmadığı için bellekte aynı yer ayrılmaz.
    - String s = "ankara";
    - String str = "ankara"; // derleyici "ankara" yazısı için tek bir adres üretir. Eğer bu nesneler new operatörü ile
      yaratılsaydı farklı adresler üretilirdi.

- Derleme zamanında çözülecek bir sorun var ise derleme zamanında çözülür.


- StringBuilder sınıfı String sınıfının mutable halidir(StringBuilder içerde char türünden dizi tutar, String sınıfı
  içerisinde CharSequence denilen bir tür vardır.)

- StringBuilder sınıfının size ve capacity denilen iki tane fonksiyonu vardır.
  Size içeride tutulan yazının uzunluğunu döndürür.
  Capacity ise maksimum artırılabilecek size'ı gösterir.(Capacity aşıldığında StringBuilder nesnesi için
  yeni bir yer tahsis edilir)

- amortized constant time (Çoğu zaman O(1) bazen ise O(n) karmaşıklığa çıkabilen karmaşıklıktır.)

- StringBuilder amortized constant time karmaşıklığı ile çalışan bir yapıya sahiptir.

- StringBuilder sınıfı içsel olarak tuttuğu dizinin elemanına capacity denir. Bizim tuttuğumuz veri eleman sayısına
  size, yada length denir.

- StringBuilder String sınıfı için yardımcı bir türdür.

- StringBuilder ctor'ları
    - default (16 karakterlik yer tutar.)
    - int capacity parametreli ctor (capacity'nin tarafımızdan belirlendiği durumlar)
    - String parametreli (String.length'i artı 16 karakterlik yer tutar.)

- Java'da bir programcı bir nesnenin hayatına son veremez.(C++' daki delete işlemi dinamik bir nesnenin hayatını sona erdirir.)

- StringBuilder türüne String türünden bir nesne atanmaz. StringBuilder s = "ankara";//error

- StringBuilder sınıfının String parametreli ctor elemanı vardır.
    StringBuilder sb = new StringBuilder(String s);

- StringBuilder sınıfının toString fonksiyonu String döndürür.

- String ve StringBuilder sınıfının indexOf methodları char parametre ile değil, string paremetre ile çalışır.

--------------------------------------------------------------------------------------------------------------
                                            07.03.2020
--------------------------------------------------------------------------------------------------------------


- StringBuilder sınıfı türünden nesne initialize edilirken verilen Stringin uzunluğu artı 16 byte'lık yer ayırır.

- delete metodu StringBuilder sınıfında verilen range'i silip kaydırma yapar.
   sb.delate(int begin, int end); [begin,end);

- getChars metodu verilen bir char array'inin içini doldurur. Herhangi bir StringBuilder sınıfının
    sb.getChars(int srcBegin,int srcEnd,char [] chars, int destBegin); //

- terim olarak append ve add fiilleri programlama da sona eklemek için kullanılır.

- insert belirli bir konuma ekleme yapar. bunun sonunda bir kaydırma işlemi yapılır.

- StringBuilder sınıfının setLength fonksiyonu length'i artırır ve geri kalan kısmı null character ile doldurur.

- setLength isimli fonksiyonu aynı zamanda küçültme de yapmamızı sağlar.

- StringBuilder sınıfının fonksiyonları
    - ensureCapacity(int val); // artırılacak minimum kapasiti değerinden küçük ise kendisi minimum değeri atar.
      Değilse bizim bildirdiğimiz değeri artar.

      StringBuilder sb = new StringBuilder("ankara"); // capacity 22
      sb.ensureCapacity(23); // capacity 46 artması gereken değer 46 olacağı için 46'ya çıkmıştır.
      sb.ensurecapacity(150); // capacity 150

    - Ya bizim verdiğimiz gereken değere çeker yada artmasa gereken değere çeker.

    - ensureCapacity değeri varolan değerden daha küçük bir değere artar.


- setCharAt fonksiyonu geçersiz length durumlarında exception throw eder.
- StringBuilder sınıfının char arayan bir indexOf fonksiyonu yoktur. String sınıfının vardır.

- subSequence(int start, int end) methodu yazı olabilen sınıflar için kullanılabilir. charSequence türüne geri döner.
  charSequence demek String demek değildir. Ama String demek charSequence demektir.

- trimToSize(); Sınıfın capacity'sini length'ine eşitler.

--------------------------------------------------------------------------------------------------------------
                                            BigDecimal class
--------------------------------------------------------------------------------------------------------------

- switch deyimlerinde double türleriyle karşılaştırma yapılamaz.

- double sayıları karşılaştırılken epsilon değeri ile karşılaştırılır.

- double sayıların kritik yerlerde kullanımı özellikle finansal uygulamalar da ortaya çıkar ve sorunları burada belli olur.

- BigDecimal sınıfı immutable'dır.
- Sınıflarda referans karşılaştırması ile nesnelerin gösterdikleri değerlerin aynı olup olmadığını
  == operatörü ile değil sınıfın ilgili metodları ile(equals, compareTo), metodları ile yapılmalıdır.
- BigDecimal sınıfının add metodu iki BigDecimal türünden nesneyi toplar.


- BigDecimal sınııfının valueOf metodu double türler için yuvarlama hatası olmaz. Verilen sayının kanonikal formunu döndürür.
  Sayı fonksiyona verilmeden önce yuvarlanmış ise kanonikal forma göre de  yuvarlanmış şekilde sayıdan nesne üretir.

- BigDecimal sınıfının min ve max metotları vardır.

- BigDecimal sınıfının public static final bazı  veri elemanları
    - BigDecimal.ZERO
    - BigDecimal.TEN
    - BigDecimal.ONE


--------------------------------------------------------------------------------------------------------------
                                            08.03.2020
--------------------------------------------------------------------------------------------------------------


- BigDecimal sınıfının compareTo metodu karşılaştırma yapar.
    bd1.compareTo(bd2)
    Değer +1 ise bd1 > bd2(bunlar içeride tutulan değere göre karşılaştırma yapılır.)
    değer -1 ise bd1 < bd2
    değer 0 ise bd1 == bd2 olur.


- iki tane sayının max'ını elde ederken yeni bir nesne elde edilmez. Verilen adreslerden hangisinin gösterdiği
  değer büyük ise o referans geri döndürülür.


- BigDecimal sınıfının non-static divide metodu,
    a.divide(Bigdecimal number, int scale, RoundingMode )
        scale .'dan sonra kaç tane basamak verileceğini bilir.
        RoundingMode'da enum türünden bir sınıftır.RoundingMode'ın belirli değerleri vardır.(RoundingMode.HALF_UP //gibi)
        RoundingMode ile yuvarlamanın nasıl yapılacağı belirtilir.



--------------------------------------------------------------------------------------------------------------
                                Bir Library(Jar dosyası) nasıl oluşturulur(intellij için)
--------------------------------------------------------------------------------------------------------------
- Java da her bir moduül birer projedir.
- Her bir modülün birer main'i olabilir.
- Jar dosyaları aşağıdaki biçimde oluşturulur.
    1- Öncelikli olarak sınıfın içindeki kodlar yazılmış olmalı
    2- project structure'dan artifact(çıktı olarak kullanılır)'s kısmından yeni bir artifact oluşturulur.
    3- Artifact'in üst taraftaki ısmı değil ancak aşağı taraftaki ismi başına alan adı şeklralinde eklenir.
       (org-csystem-mathlib) - olmasının nedeni dosya olacağı için nokta koyamamızdan kaynaklıdır.
    4- Build kısmından oluşturulan artifact'ler build artifacts seçeneği ile build edilir.
--------------------------------------------------------------------------------------------------------------
                                Bir Library(Jar dosyası) nasıl projeye eklenir(intellij için)
--------------------------------------------------------------------------------------------------------------

- Öncelikli olarak library'ler projeye eklenirken proje klasörümüzde bu jar dosyalarını bulunduracağımız,
  bir klasör de olması daha iyi olur.(İsmi libs olabilir)
  Bu klasörde bulunan dosyaları eklemek için projects structure'dan library sekmesine tıklayarak ilgili
  jar dosyaları projelerimizi ekliyoruz. Bu dosyaları projemizde ekleyeceğimiz modülü seçebiliriz.

--------------------------------------------------------------------------------------------------------------
                                                14.03.2020
--------------------------------------------------------------------------------------------------------------

- SimpleProductMenuApp uygulaması yapıldı.


--------------------------------------------------------------------------------------------------------------
                                                15.03.2020
--------------------------------------------------------------------------------------------------------------

- Çalışabilen bir jar için içindeki main fonksiyonu da seçilmelidir(ArrayUtil çalışabilen bir jar değildir.).
  Burada çalışabilen jar'a örnek olarak simple product menuapp'si örnek olarak verilebilir.

--------------------------------------------------------------------------------------------------------------
                                                BIGINTEGER
--------------------------------------------------------------------------------------------------------------

- ONE, TEN TWO, ZERO gibi final static public veri elemanları vardır.

- Önemli fonksiyonlar
    - String parametreli ctor// BigInteger(string val);
    - String ve int radix paramatreli
      //BigInteger(string val, int radix); radix paramatresi  hangi sayı sistemine göre sayının okunacağını belirtir.
       BigInteger("ababab", 16); // sayı 16'lık sistemde okunur.
       BigInteger("765", 8); // sayı 8'lik sayı sistemini göre okunur.
    - static valueOf metodu(long val);

    - sınıfın IntValue ve DoubleValue metodları mevcuttur. Tür dönüşümü yapıp artık bitleri atar.

    - mod almak için mod metodu kullanılır.

- BigInteger sınıfında new operatörü ile yaratılan bir nesne ile final değişkenlerin(BigInteger.ZERO gibi)  == operatörü
  ile karşılaştılması doğru sonucu vermez.
  BigInteger zero = new BigInteger("0");
  System.out.println(zero == BigInteger.ZERO);//false döndürür. Çünkü referans karşılaştırılmasında
  sınıf immutable olmasına rağmen referansın biri new keyword'u ile yaratıldığından dolayı farklı sonuçlar verir.
  Eğer değer valueOf ile alınmış olsaydı sonuç doğru olurdu.(Burası final static değerler için geçerlidir.)

- == operatörü ile yapılan bir karşılaştırma her zaman referans karşılaştırması olur. Bu durumda new operatörü ile yaratılmış
  aynı değere sahip nesneler her zaman farklı adresleri gösterirler.

- Eğer sınıflar'ın valueOf metodu var ise ve immutable sınıf iseler valuOf metodu aynı adres değerlerini döndürür.
    BigInteger.valufeOf(2) == BigInteger.valueOf(2);

--------------------------------------------------------------------------------------------------------------
                            DEĞİŞKEN SAYIDA ARGÜMAN İLE ÇALIŞAN METODLAR.(VARARGS METODLAR)
--------------------------------------------------------------------------------------------------------------

- Metod ne şekilde yazılırsa yazılsın metodun içindeki parametre değişkeni dizi referansıdır.
- Böyle fonksiyonlar değişken sayıda yani
      Util.display(10,20,30,40); // derleyici burada new int[]{10,20,30,40} şeklinde bir kod üretir.
      Util.display();
      Util.display(new int[]{1,2})
  argümanları ile çağırılabilir.

- class Util {
    public static void display(int ...a) // değişken sayıda int türden eleman alabilir.
    {
        //... atomuna elipsis atomu denir.
    }
  }

- elipsis atomu dilden dile farklı şekilde yazılabilir.

- varags bir metod [] referansı ile overload edilemez.
    public void display(int [] a);
    public void display(int ...a); // ikisinin aynı anda olması errordur.

- Bunun dışında fonksiyon herhangi bir parametre ile overload edilebilir.

- Bir metodun bir elipsis parametresi var ise elipsis parametresi en sondaki parametre olmalıdır.
    void display(int ... a, int n) ;//error

- Bir metodun birden fazla elipsis parametresi olamaz.
  public static void display(int ...a, String ...b) // error

- printf fonksiyonun birincisi parametresi String s, ikinci parametresi Object ... args'dır.

- iki tane varags parametreli metod yazılmak istenirse biri dizi referansı yapılmalıdır.

- matrisler le elipsis işlemi yapmak için fonksiyon parametresi
  class Util {
    public static void display(int [] ... a)
    {

    }
  }

- varargs metodlar sadece fonksiyon bildiriminde bulunabilir. Bunun dışında değişken bildiriminde yada sınıf bildirimin
  de bulunamazlar.

- Burada fonksiyona geçilecek parametre ya elipsis atomundan önceki atom türünden 0 yada en az 1 adet olmalı,
  yada elipsis atomunu da kapsayacak şekilde (int ... a için int [], int [] ... a için  int [] []) bir adet argüman
  gönderilebilir.


--------------------------------------------------------------------------------------------------------------
                                                21.03.2020
--------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------
                                                KOMUT SATIRI ARGÜMANLARI
--------------------------------------------------------------------------------------------------------------

- Özellikle bazı server uygulamalarında kullanılmaktadır.
- komut satırı argümanlarının uygulamaya geçilmesi için uygulamanın konsolda çalışması gerekmektedir.
- komut satırından uygulamayı çalıştırmak için, console'dan
    - java org.csystem.app.App <argümanlar>

    - eğer uygulama bir çalışabilen jar dosyası olarak çıkarıldı ise
      java -jar şeklinde <applicationname> <argümanlar> şeklinde çalıştırılmalıdır.
--------------------------------------------------------------------------------------------------------------
                                                var keyword
--------------------------------------------------------------------------------------------------------------

- Java 10 ile eklenmiştir. Yerel değişken bildirimlerinde kullanılır.
- Java 11 ile birlikte lambda ifadelerinde de kullanılmaya başlanmıştır.

- var anahtar sözcüğü değişken ismi olarak kullanılabilir.

- var anahtar sözcüğü ile belirtilen değişkene ilk değer verilmesi zorunludur.
  Çünkü değişken türünü  verilen ilk değere göre belirlenir
  var a = 10; // a'nın türü 10 olarak belirlenmiştir.

- var anahtar  sözcüğünün büyük özelliği kod yazımını basitleştirmektir.

- var anahtar sözcüğü parametre değişkeni bildiriminde kullanılamaz.

- var bir sınıfın veri elemanı olarak ta belirlenemez.

- sadece yerel değişkenler(Dikkat for deyiminin içi bir yerel bloktur.) ve lambda ifadelerinde kullanılır.

-

--------------------------------------------------------------------------------------------------------------
                                                22.03.2020
--------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------
                                                Arrays sınıfı
--------------------------------------------------------------------------------------------------------------

- Diziler üzerinde  işlem yapmak için kullanılan bir sınıftır.
- ctor'u private'tır. Metodlarının hepsi static'dir.

- Arrays sınıfının temel işlemler yapan metodları
    - fill metodları
        Arrays.fill(T [] a, int val); // verilen array'i verilen değer ile doldurur;
        Arrays.fill(T [] a, int fromIndex, int toIndex, int val) [fromIndex, toIndex) // verilen array'i index'ler arası
        verilen değer ile doldurur.

    - T [] a copyOf metodu // yeni bir dizi tahsis eder ve değerleri kopyalar, yeni üretilen diziyi küçültebilir.

    - Arrays.fill(T [] a, int newLength); // yeni bir dizi döndürür. newLength ile o uzunlukta bir dizi üretir ve
      dizinin değerlerini kopyalar. diziyi aynı zamanda küçültedebilidir.(Yani eleman sayısı küçültülmüş yeni bir dizi
      verebilir.)

    - T []  copyOfRange(T [] a, int fromIndex,  int toIndex); // copyOf [fromIndex, twoIndex]

    - booleans equals(T [] a, T [] b); // dizilerin eşitlik karşılaştırması yapar.

    - int compare(T [] a, T [] b);
        - Java 9 ile beraber eklenmiştir.
        - Eğer ilk parametredeki dizi büyük ise pozitif, küçük ise negatif, birbirine eşit iseler 0 değerini döner.
        - ilk farklı değer'den büyük olanın değerini döndürür.
        - length'ler farklı ve iki  array'in ilk n(n burada küçük dizinin size'ına kadardır) değeri karşılaştırır.
          eğer burada farklı bir değer var ise döner, eğer değerler eşit ise hangi dizinin size'ı daha büyük ise o
          dizinin bulunduğu konuma göre (Size'ı büyük olan dizi ilk parametre ise pozitif değer, ikinci ise negatif)
          değer döner.



    void sort(T [] a);
        - verilen diziyi küçükten büyüğe sıralar.

    void sort(T [] a, int fromIndex, int toIndex)
        - diziyi [fromIndex, toIndex) bu aralıkta sıralar.

        Büyükten küçüğe de çalışır ancak bunun için collection'lar konusunu görmemiz gerekir.

    String toString() metodları
        Bir diziyi alıp Stringe dönüştürür [] içine alıp delim olaral ,  kullanılır.
        Yazıya çevirirken String sınıfının valueOf metodunu kullanır.

- Javadaki bütün tam sayı türleri pozitif ve negatif sayıları tutulabilir(Yani unsigned bir primitive tür yoktur).

     Arrays.compareUnsigned(int [] a, int [] b)
        - burada sayının negatif değerleri için sayının bitlerini 2'ye tamamlayarak pozitif değere döndürür.

- Genel olarak veri tutan(Data class) Sadece veri tutmaya yarayan sınıfların, toString'i olur.

--------------------------------------------------------------------------------------------------------------
                                                04.04.2020
--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
                                                İçiçe sınıf bildirimleri
--------------------------------------------------------------------------------------------------------------

- 4 biçimde yapılabilir.
    1-) static sınıf bildirimi (nested)
    2-) non-static sınıf bildirimi (inner)
    3-) yerel sınıf bildirimi
    4-) isimsiz sınıf bildirimi


---- Static sınıf(nested) bildirimi ----

- Hiç bir sınıf içerisinde bulunmayan bir sınıf (top level classes) static olarak bildirilimez.
    package org.csystem.app;
    static class  Mycass {} // error

- Bir sınıf içerisinde başka bir sınıf static olarak bildirilebilir. İçteki sınıf dıştaki sınıfın bir elemanıdır.
  Dolayısıyla bir eleman static olabileceğinden sınıfta statik anahtar sözcüğü ile bildirilebilir.

- Tüm elemanlarda olduğu gibi içte bildirilen bir sınıf erişim belirleyicisi olabilir.(public, protected, private, non-modifier)
  Top level classes'ların private olması gibi bir durumu yokken bu inner class'lar için bu durum geçerlidir.

- Static bildirilmiş sınıflar  normal sınaflarda olduğu gibi memberlara(method yada değişkene) sahip olabilirler.

- static bildirilmiş sınıflar onu kapsayan sınıf dışından, kapsadığı sınıf ismi ve . operatörü ile erişilebilir.
    Myclass.innerMyclass b = new Myclass.innerMyclass();
    class Myclass {
        public static class innerMyclass{}
    }

- Bu composition ile karıştırmamak geerekir bu tamamen yeni bir tür bildirimidir.

- import static direktifi ile bu static class'a nitelemeden kullanabiliriz.
    import static org.csystem.app.Myclass.innerMyclass;

- Kapsayan sınıfta static olarak bildirilen sınıfın elemanlarına erişilebilir.

- top level bir sınıftan ilgili sınıfın static member class'ların private elemanına erişilebilir.

- static bir sınıftan kapsayan sınıfın private elemanlarına erişim sağlanabilir.

- static bir sınıfın en büyük artısı içtekinin dıştaki sınıfın yada dıştaki sınıfın içteki sınıfın
  private elemanlarına erişimimizin olmasıdır.

- static sınıflar Builder design pattern'inde sıkça kullanılır. Bunun nedeni sınıfa sanki istediğimiz
  değerler ile yaratma şansımızı verir.

- StringBuilder sınıfıda bir Builder design paterninin sonucudur. Ancak böyle bir şeyin implemente ediliş şekli
  daha farklıdır.

------- non-static(inner) sınıf bildirimi -------

- Bir sınıfın içerisindeki sınıf non-static bildirilmiş ise böyle sınıflara inner class denir

-  inner class'ın static bir member yada static bir methodu olamaz.

- non-static bir sınıf(inner class) türünden bir nesne yaratmak için
    <top_class_name>.<inner_class_name> <variablename> = <top  class reference>.new <innerclass name>();
    A a1 = new A();
    A.B y = a1.new B();
    A.B z = a1.new B(); // şeklinde yapılabilir.

    class A {
      class B{}
    }

- içsel bildirilen bir nesnenin non-static bildirilmiş nesnesine ortada içsel türden bir nesne
  yok ise errordur.
- non static(inner) bildirilmiş bir nesne kapsayan sınıf dışında <referans>.new sentaksı ile
  yaratılabilir.

- inner class'lığın inheritance'lık ile alakası yoktur. Ancak ve ancak bir ilişki veirlecek ise
  aggregation olabilir.

- inner class'lar ilişkin olduğu kapsayan sınıf nesnesinin non-static ve static veri elemanlarına doğrudan erişebilir.

- inner class'lar da içteki nesneyi yaratılabilmek için onu kapsayan sınıf türünden bir nesneye ihtiyaç vardır.

- Genelde inner türden nesneleri dışarıda değilde sınıfın içinde yaratırız.

- static bir fonksiyondan sınıfın non-static bir inner class'ı yaratılamaz.
  Çünkü inner class'ın türünden bir nesne içinde kapsayan türden bir referansın kime ait olacağını
  belirlenemez.

- javac içsel static ve içsel non-static sınıflar için .class dosyasını A$B.class şeklinde
  oluşturur.

- this anahtar sözcüğü non-static metod ile çağırılan referansın adresini gösterir.

- this expression'ının  inner class'lar ile kullanılımı

class A {
    private int m_val;
    public void foo()
    {
        System.out.println("A.foo")
    }
    class B {
        private int m_val;
        public void foo()
        {
            System.out.println("B.foo")
            A.this.foo(); // this expression ile A sınıfının foo fonksiyonu  çağrılmıştır.
            this.m_val = 10;
            A.this.m_val = 20; //
        }
    }
}


- inner class'larda kapsayan sınıfın bir elemanı ile aynı ise sahip bir member var ise
  top class'ın member'ına erişmek için <top_class_name>.this.member sentaksı kullanılır.
  Bu duruma this expression denir.
  class A {
    private int x;
    class B {
        private int x;
        public void foo()
        {
            System.out.println(A.this.x);
        }
    }
  }
--------------------------------------------------------------------------------------------------------------
                                                05.04.2020
--------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------
                                                Recursive algoritmalar
--------------------------------------------------------------------------------------------------------------

- Özyineleme gerektiğinde kullanılması gereken bir durumdur. Çalışılırken dikkat edilmesi gerekir. Örneğin gömülü
  sistemlerde recursive algoritma hiç tercih edilmez.

- recursive algoritmalar kendini ne kadar çok çağırırsa stack'i o kadar doldurur.

- Eğer recursive algoritmalar yerine  algoritma döngü ile  yapılabiliyor ise(Eğer recursive ile çok daha hızlı
  yapılmıyor ise) recursive function tercih edilmemelidir.

- örneğin factorial fonksiyonu recursive şeklinde yazılmak yerine iteratif şeklinde yazılması daha iyidir.

--------------------------------------------------------------------------------------------------------------
                                                11.04.2020
--------------------------------------------------------------------------------------------------------------

- sınıf içerisinde enum türü bildirilebilir. Doğası gereği new operatörü ile yaratılamayacağı için statik bildirilsin
  yada bildirilmesin statik kabul edilir. Hatta statik bildirilirse derleyici statik yazılmasına gerek olmadığına dair
  uyarı verir.


- local classes(yerel sınıflar) :
    - Bir metod içerisinde bildirilen sınıflara  yerel sınıflar denir.

    class Sample {
        public void foo(){
            class A {

            }
            class B{

            }
        }
        public void bar(){
            class A {

            }
            class B{

            }
        }
    }

- Java da her bir sınıf kodu için bir .class dosyası üretilir.
    - local sınıflar için durum : Sample$1A.class şeklinde oluşturur(<taban sınıfı>$<localsınıf ismi>)

- yerel sınıflar faaliyet alanı bakımından bildirildileri fonksiyonun içinde bildirildikleri yerden
  bloğun sonuna kadar görülebilirler.

- yerel sınıflar erişim belirleyicisi  yada statik bildirilmesi gibi bir durumu yoktur. Böyle bir durumda bildirilmesi
  errordur.
  class A {
    public void foo()
    {
          public class B {} // error
          static class C {} // error
    }
  }

- yerel sınıflar başka bir sınıftan(local bir sınıf olabilir.) türetilebilir.(Burada base class'ın türemiş sınıfın
  görebileceği scope içerisinde olması gereklidir sadece).

- yerel bir sınıf kendisinden önce bildirilen yerel değişkenleri ve parametre değişkenlerini yakalayabilir.
  (Buna capture denir.)

  class Sample {
    public void foo(int val)
    {
        int a = 15;
        class Util {
            public boolean isEven(){return val % 2 == 0;}
            public boolean isOdd(){ return val % 2 != 0;}
        }
        var util = new Util();
        sout(util.isEven());
        sout(util.isOdd());
    }
  }

- Java da yerel fonksiyonlar olmadığı için  onların görevini yerel sınıflar ile yapılır.

- Bir yerel değişken bir local sınıf içerisinde kullanılmış(yakalanmış) ise ikinci bir değer atanamaz.
  Değiştirilmiş bir yerel değişkende yakalanamaz.

- Java 8'den itibaren yakalanmış olan yerel veya parametre değişkenlerine effectively final denir.
  Java 8 öncesinde ise yakalanabilecek değişkenler final bildirilmek zorundaydı

- java 8 öncesinde yerel değişkenler de final kullanımı böyle durumlar için geçerliydi

----- Anonim sınıflar -----

- Anonim sınıf bildiriminin genel biçimi aşağıdaki gibidir
  new <tür>([argümanlar]) {};

- Yukarıdaki bildirim bir anonim sınıf bildirimidir, aynı zamanda da bir nesne yaratılması
  işlemidir. Anonim sınıf bildirimi new operatörüne yazılan sınıf türünden türetilmiş olan bir sınıfın
  hem bildirimi hem de o sınıf türünden nesne yaratılması anlamına gelir.

   new Sample(){};
   class Sample {}

- final bir sınıf türünden anonim sınıf yazılamaz.
    new Sample(){}; // error.
    final class Sample {}

- anonim sınıf yazımı aynı zamanda bir bildirimdir. Bu yüzden anonim sınıfı yazarken ilgili
  taban sınıfın fonksiyonları anonim sınıf içerisinde override edilebilir. Eğer ilgili taban sınıfın bütün abstract
  metodları implemente edilmelidir.

   Sample s = new Sample() {
                public void foo()
                {
                    sout("Anonim class");
                }
              };

  class Sample {
    public void foo(){}
  }

--------------------------------------------------------------------------------------------------------------
                                                12.04.2020
--------------------------------------------------------------------------------------------------------------

- abstract sınıftan türetilmiş anonim sınıflar
    - Anonim sınıflar abstract sınıflardan türetilirse, abstract sınıfın tüm abstract metodları
      override edilmek zorundadır. Override edilmemesi halinde error oluşur.

    - Abstract türünden referans'lar genellikle bir fonksiyonun parametre değişkeni olarak kullanılır.

- anonim sınıflar farklı paketteki bir sınıf türünden isim ile yaratılıyor  ise bu sınıfların protected bölümüne
  erişebilir.

- anonim sınıflar da yerel sınıflarda olduğu gibi kendisinden önce bildirilen yerel değişkenleri veya
  parametre değişkenlerini yakalayabilirler. Bu durumda yine final olmayan bir yerel değişken veya parametre değişkeni
  için effectively final kuralları geçerlidir.

- callback : Ne yapılacağını dışarıdan alan(Yani bir bakıma functor sınıflardır.) fonksiyonlardır.

- callback tarzı sınıflar genel olarak belirli periodlar ile çalışan metodlara geçilen metodlardır.  Böyle metodlara
  timer metodlar denir.

--- Timer class ----
    - Timer işlemlerinde kullanılan en temel sınıflardan biridir.
    - Kursta şu anda saddece default ctor'u kullanılacaktır.
    - sınıfın scheduleXXX metorları ile ayrı bir akış oluşturulur. ve girilen perioda göre TimerTask referansı
      ile aldığı türe ilişkin run metodu çağırılır. TimerTask parametresine, TimerTask türünden anonim bir sınıf
      geçilebilir.


--- Timeunit enum'ı -----
    - Timeunit enum'ı girilien değerin hangi saniye cinsinden olduğunu belirtir.(1,TimeUnit.HOURS) // Burada girilen 1
      sayısı saat cinsinden verilmiştir. yani kullanıcıya TimerTask için milliseconds türünden değil saat, saniye, dakika
      cinsinden istenildiği gibi verme gösterme imkanı sunulmuştur.



--------------------------------------------------------------------------------------------------------------
                                            19.04.2020
--------------------------------------------------------------------------------------------------------------

- anonim sınıflar sadece abstract sınıflardan değil ayrıca somut türlerden türetilebilir.

- anoninm sınıflara non-static initializer yazılabilir. non-static initializer kullanılarak nesnelere değer verilebilir.
- Burada eğer non-static initializer taban sınıfın nesnelerine erişiyor ise bu nesnelere ilk değer veriyormuş gibi
  kullanılabilir.

- Point p = new Point(){ {x = 10; y = 20;} }; // şeklinde bir kod sanki Point türüne kullanıcı tarafından istenilen bir
  değer atanıyormuş.


- anonoim sınıf herhangi bir  sınıftan türetiliyor ise hem yeni bir sınıf bildirimi hemde nesne yaratma işlemidir.
- anonim interface ise bir interface bildirimi ve implementasyonudur.

- Anonim sıfılar teknik olarak ya bir interface'i implemente edecek yada anonim bir sınıftan türetilecektir.
- Anonim sınıflar final bir sınıftan türetilemez.
- anonim bir sınıf birden fazla interface'i implemente edecek şeklinde yazılamaz.

- Bir metodun başka bir çağıracağı metodu yapabilmesine high  order function denir(Ne yapacaığını dışarıdan almak).
  Timer sınıfının schedule metodu tamamen böyledir(Ne yapacağını TimerTask interface'inin run kodunun yazılme şekline
  bağlıdır.).




--------------------------------------------------------------------------------------------------------------
                                            Lambda ifadeleri(Lamba expressions)
--------------------------------------------------------------------------------------------------------------


- içerisinde bir ve yalnız bir tane abstract metod olan interface'lere fonksiyonel interface denir.
    interface IX {
        void foo();
        default void bar()
        {
        }
    } // IX interface'i bir functional interface'dir. Çünkü bar metotu abstract değildir.

- Java 8 ile birlikte eklenmiştir.

--- Lambda ifadelerinin genel biçimi ------

- Lambda ifadeleri uygulanabilecek her yerde uygulanılmalıdır(always applicable).

    1- (değişken_listesi) -> ifade
    2- (değişken listesi) -> {...}
    3- değişken -> ifade
    4- değişken -> {...}
    5- () -> ifade
    6- () -> {}
    7- (<tür değişken listesi>) -> ifade
    8- (<tür değişken listesi>) -> {}

- Yukarıdaki 8 yazım şekli lamba ifadelerinin genel implementasyon biçimidir.

- Lambda ifadeleri ancak ve ancak uygun fonksiyonel arayüz(interface) referanslarına atanabilir. Arayüz dışında herhangi
  bir referansa yada fonksiyonel olmayan arayüz referanslarına atanamaz(örneğin abstract bir sınıf referansı, yada
  fonksiyonel  olmayan bir interface referansına atanamaz.).

- Lambda ifadesi ile fonksiyonel bir arayüzün o bir tane olan fonksiyonun için anonim bir class yazıp fonksiyonu
  override etmek  yerine geçen kodu kısa bir biçimde yazmış oluruz.

- Lambda ifadesinde ki okun sol tarafı uygun fonksiyonel arayüzün değişken listesini temsil eder(tür yazılmak zorunda
  zorunda değildir. Okun sağ tarafı ise hangi işin yapılacağını temsile eder.).
--------------------------------------------------------------------------------------------------------------
                                            25.04.2020
--------------------------------------------------------------------------------------------------------------

- Lambda ifadeleri bir ifade olduğu için bir türleri vardır.

- Lambda ifadesi tam olarak atandığı fonksiyonel arayüz referansının ilgili abstract metodunu override edilmiş
  hali gibidir.

- Fonksiyonel arayüzler sanki  metot tutabilen bir türmüş gibi davranan arayüzlerdir. Lambda'lar da sanki
  bu fonksiyon türüymüş ve fonksiyonel arayüze atanan bir tür gibidir.


- callback kavramı tam olarak bir programa ne yapacağımızı bizim vermemizdir. Diyebiliriz. Fonksiyonel arayüze göre
  yazılan kütüphaneler callback ister ve ona geçilen callback'i çağırır.

- Java da ki bu fonksiyonel arayüzler bir function pointer gibi davranırlar
- lambda ifadelerinde oktan öncesi kısım bize parametrik yapıyı gösterir.

- Lambda ifadeleri için derleyici arka planda başka bir sınıf yada anonim sınıf oluşturmaz.

- Lambda ifadelerine ilişkin olarak, ilgili ifade bir çok kez yeniden kullanılabilir.

- Lambda ifadesi atanacağı fonksiyonel arayüzün abstract fonksiyonuna uygun bir parametrik yapıda yazılmalıdır.
- Lambda ifadeleri uygun fonksiyonel inteface'lere atanabilir. Lambda ifadeleri tür çıkarımı yapılacak ise
  tür çıkarımını kendisi yapacaktır.

- Lambda ifadesinde tek bir değişken var ise tür tarafına yazılan parantezlere gerek yoktur.
  IIntUnaryOperator op = a -> a * a; // burada oktan önceki yer bir bildirim gibidir. Burada sadece a değişkeni
  bildirilmiştir.
  IIntBinaryOperator op = (a, b) -> a + b; // burada a ve b değişkenleri bildirilmiştir. ok'un sağ tarafı
  ise yapılacak işlemi gösterir.

- Eğer birden fazla işlem yapılacak ise method gövdesi biçiminde yazılabilirler.
     IIntBinaryOperator op = (a, b) -> {
        sout(a + " " + b);
        return a + b;
     }

- ilgili functional interface generic bildirilse bile tür çıkarımını kendisi yapabilir.
    IBinaryOperator<Integer> opInt = (a, b) -> a + b;
    IBinaryOperator<String> opStr = (name, surname) -> name + " " + surname;

interface IBinaryOperator<T> {
    T apply(T a, T b);
}

- anonim sınıflar lambda ifadelerinin yerine geçerken, lamba ifadeleri anonim sınıflar yerine kullanılamaz.
  Kullanabilen her yerde lamba ifadeleri kullanılabilir.

- Lambda ifadelerinin parametre değişkenleri yerel değişken kabul edilir ve ilgili Lambda ifadesi boyunca görülebilir.

- Lambda ifadelerinde bildirilen bir yerel değişken ile aynı isimde başka bir yerel değişken o scope boyunca yeniden bildirilemez.

- Lambda ifadeleri de yerel ve anonim sınıflar gibi bulunduğu kod bloğundaki bir değişkeni yakalayabilir. Burada
  yakalanan değişken değiştirilemez. Yani yakalanan değişken effectively finaldır.

- Fonksiyonel arayüzler generic interface'ler ile kullanılabilir.
  Basit bir convert işlemi

  IFunction  s2l = a -> a.length();
  s2l.apply("ankara");//6
  interface IFunction<T, R> {
    R apply(T t);
  }

- lambda parametreleri içerisinde tür yada var keywordu kullanılabilir. Ancak tür kullanılse bile lambda ifadelerinin atanacağı
  referans var keyword'u ile belirtilemez.

- Java 11 ile parametre tür dğeişkenleri var ile bildirilebilir.
    IBinaryOperator binaryOperator(var a, var b) -> a + b; // since java 11;
    interface IBinaryOperator {
        int apply(int a, int b);
    }

- fonksiyonel arayüz referanslarına eğer elimizde parametrik yapısı tam uyumlu bir reference var ise bu metot ::
  (çözünürlük) operatörü ile doğrudan atanabilir.
- metod reference'lar non-static metodlar ile de yapılabilir.Ortada bir refence olması gerekir.



- metot reference'ın genel biçimi statik metodlar için <class Name>::function_name;//şeklindedir.

- metot reference'ın non-static metotlar için genel biçimi ise <reference>::function_name;

- Metod reference'ları non-static fonksiyonları(Örneğin String length fonksiyonu), sanki bir statik metotmuş gibi
  kullanılabilir. Bu tammen run-time'da static fonksiyonların non-static fonksiyonlara çevrilmesi ile alakalıdır.

- <Sınıf ismi>::new sentaksı ctor çağrılmasını sağlayan sentaksıdır. Bu durumda interface'in ilgili sınıf türüne dönen
  bir tan abstract metodu olmalıdır. Ayrıca sınıfın da bu abstract metodun parametrik yapısına uygun bir ctor'u
  bulunmalıdır. Burada ctor parametresiz ise parametresiz bir abstract metod bulunmalıdır.

- ctor parametreli yazılmış ise ona göre de interface'in  parametreli yazılmış olması gerekir. Bizde Yazacağımızı yapıyı
  buna göre düzenlemeliyiz.

--------------------------------------------------------------------------------------------------------------
                                            26.04.2020
--------------------------------------------------------------------------------------------------------------


-------- Metot referans çeşitleri -------
- Pratikte kullanılan 4 çeşit metot referans vardır.
    1-) static metot referansları(reference to a static metod)
    2-) Bir nesneye ilişkin non-static metotun reference(reference to an instance(non-static) method of particular object)
    3-) Bir türe ilişkin  non-static metot referansı (reference to an instance(non-static) metot of any object of particular type)
    4-) Ctor referansı(Reference to a ctor  <Sınıf ismi>::new şeklinde kullanılır. Uygun arayüze atanabilir.

- Java da generic sınıfların wrapper sınıflar için kullanılabilen bütün interface'lerin ayrıca primitive türler için
  ayrıca temel türler için olan kısmı ayrıca yapılır.



----- Java'nın function paketi ------

- java.util paketi altındadır. içerisinde functional interface'ler vardır. Birçok interface generic bildirilmiştir.
  Sadece primitive türler için olanlar generic bildirilmemiştir.Bu fonksiyonlar Int, Double, Long ekleri ile belirtilmiştir.

- Bütün interface'ler FunctionalInterface annotation'ına sahiptir.

- Function interface'i
    - kendisine verilen argümana göre bir sonuç üreten.
- Predicate interface'ler
    - geri dönüş değeri boolean olan abstract fonksiyonu test ile isimlendirilmiş, veriyi alıp test eden interface'dir.

- Supplier grupları
    - Parametre almadan tür döndüren sınıflardır(Random sınıfının nextInt metodu için kullanılabilir.).

- callback : bir metod dışarıdan hangi metodu çağıracağını alırsa böyle parametrelere call back denir. Bu tarz metodlar
  high order metodlar denir.

- function paketinin detaylarını değil daha çok kullanımını göz önünde bulundurmalıyız.

- function sınıfının bütün interface'lerini ezberlemek değil, kullanarak akılda kalması sağlanmalıdır.



------------------------------------------------------------------------------------------------------------------------
                                            02.05.2020
------------------------------------------------------------------------------------------------------------------------

- CommandPromptApp uygulaması yapıldı

------------------------------------------------------------------------------------------------------------------------
                                            03.05.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            Optional sınıfı
------------------------------------------------------------------------------------------------------------------------

- Java 8 ile eklenmiştir, Generic bir sınıftır. Bu tarz türlere nullable type'lar denir.

- Optional türü bir nesne var ise kullanılıp, eğer nesne yok ise  herhangi bir şey yapmayacaktır. Optinal sınıfı ortada
  bir işi exception olmadan halletmenin yöntemidir.

- Sınıfın static empty metodu ile boş bir optional nesnesi elde edilir.

- Optional sınıfının of metodu ile bir bilgi Optional türüne dönüştürülür. Java'nın x. versiyonundan sonra valueOf
  metodları of olarak isimlendirilmeye başlamıştır. Optional.of(T t)

- Sınıfın isPresent metodu ile bir optional nesnesinin dolu olup olmadığını test ederiz. isEmpty ilede argüman geçilen
  nesnenin boş olup olmadığı test edilir.

- Sınıfın static ofNullable fonksiyonuna geçilen parametre null ise empty bir optional değil ise dolu optional referansı
  döndürür.

- Optional içerisindeki isPresent ve empty fonksiyonları bir flag ile kontrol edilerek yapılır.

- sınıfın non-static get fonksiyonu ilgili optional referansın sarmaladığı değeri geri döndürür.

- Optional sınıfının ctor'u private'tır.

- sınıfın ofNullable metodu aldığı parametre null ise boş null değil ise dolu optional referansı döndürür.

- bunu of metodu ile yapamayız, of metoduna null geçmek NullPointerException fırlatılmasına sebep olur.

- orElse metodu eğer kullanılan referans boş ise geçilen default değeri, dolu ise içerisindekini verecektir.
  orElse metodunun karşılığı aşağıdaki gibidir. Hangi türe
  Optional<String> r  = Optional.of("ankara");
    String s = r.isPresent() ? r.get() : "ankara";

- orElseGet metodu parametre olarak supplier'ın covariant açılımını alır. Yani oraya vereceğimiz lambda ifadesinin
  geri dönüş değeri ya açıldığı türden olmalı ya da o türden türemiş bir tür olmalı
- orElseThrow metodu eğer verilen referans boş ise bir NoSuchElementException throw edilecektir.
  bir tane overload'ı vardır.

- ifPresent'in Consumer<? super T> action parametreli metodu eğer verilen optional referansı dolu ise yapılacak işi gösterir.

- Consumer interface'i kendisine gönderilen parametre ile bir iş yapıp değer döndürmez.

- filter fonksiyonuna argüman olarak geçilen predicate sağlanıyor ise, ilgili optional referansını,
   sağlanmıyor ise empty Optional referansı döner.

- map fonksiyonu : parametresi Function interface'i türündendir. Bir optional sınıfından başka bir optional elde etmemizi
  sağlar. map empty bir optional referansı ile çağırılırsa empty Optional türüne döner.

- Function(BiFunction da dahil) açılımına göre verilen paramatrelere göre farklı bir değer üretir.

- Optional sınıfının kullanım çeşitleri
    1-) fonksiyonun geri dönüş değeri
    2-) fonksiyon parametresi (az rastlanmaktadır.)
    3-) Sınıfların veri elemanları da optional olabilir.
------------------------------------------------------------------------------------------------------------------------
                                            09.05.2020
------------------------------------------------------------------------------------------------------------------------


- API nedir ?
    - Aslında aşağı seviyeli kullanılan bir kavramdır.
    - İşin detaylarını bize göstermeden kullanıma odaklı kullanılan sınıflar(örneğin yazdığımız DateTime sınıfı).

------------------------------------------------------------------------------------------------------------------------
                                            LocalDate, LocalTime ve LocalDateTime sınıfı
------------------------------------------------------------------------------------------------------------------------

- Java 8 ile birlikte bir LocalDate, LocalDate ve LocalDateTime API'leri eklenmiştir. Immutable  sınıflardır.

- LocalDate sınıfının ctor'u yoktur. of metodu ile nesne yaratılır. getter'ları ayrı ayrı yazılmıştır. setter'ları yoktur
- Month enumları vardır, ayrıca int'e dönen month değerleri doğru tarihleri döner.
- Geçerlilik kontrollerini yaparlar.
- now metodu ilgili günü döndürür.
- isAfter ve isBefore metodları vardır.

- sınıfın plusXXX metodları ve minusXXX metodları ilgili tarihe ekleme ve çıkarma yapabilir.

- LocalTime sınıfının atDate fonksiyonu parametresine geçirilen LocalDate göre bir LocalDateTime nesnesi döner.
- LocalDate sınıfının atTime fonksiyonu parametresine geçirilen LocalTime göre bir LocalDateTime nesnesi döner.

- ChronoUnit enum'ı
    - belirli  olan(seconds,days,months) gibi enum constant'larına sahip
    - between adlı metodu ile verilen iki tarih arasındaki farkı ilgili enum sabitine çevirir.
        ChronoUnit.DAYS.between(m_birthDate,LocalDate.now());//iki tarih arasındaki gün farkını bulur


- Void sınıfı işlen
------------------------------------------------------------------------------------------------------------------------
                                            10.05.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            assert işlemi
------------------------------------------------------------------------------------------------------------------------

- assert expression'ının kullanımı
    assert [boolean ifade]  [: void olmayan ifade]

- eğer ki assert deyimine ilişkin ifade true ise akış assertten devam eder false ise AssertionError nesnesi fırlatılır.
  void olmayan ifade de burada exception'a ilişkin mesajı temsil eder.
- dile özgü bazı testleri çok anlaşılır bir şekilde yapılmasını sağlar.

- assert expression'ı program ancak ve ancak -ea yada -enableassertions modunda çalıştırıldığı zaman  çalışan
  bir expression'dır.

- assert işlemi derlemeye yönelik bir işlem değildir. runtime da yapılacak bir işlemdir. Ancak bu kullanıcıyı
  ilgilendiren bir işlemde değildir. Bu kodu yazan kişinin kendisinin yazdığı kodu kontrol edilmesi için kullanılır.

- assert işleminde eğer fonksiyon çağrılıyor ise dikkatli olunması gerekir. Eğer ki -ea flagı girilmemiş ise ve ilgili
  fonksiyonun her türlü çağrılması isteniyor ise ilgili fonksiyon çağrısını daha önceden yapmalıyız.


------------------------------------------------------------------------------------------------------------------------
                                            Annotation(Ek açıklama)
------------------------------------------------------------------------------------------------------------------------

- Java 5 ile eklenmiştir.
- bir annotation bildirimi @interface bitişik biçiminde yapılır.
    @interface MyAnnotation {
    }

- annotation nerelere konulabilir?
    1- Bir sınıfın başına
    2- Bir metoda
    3- Bir veri elemanına
    4- bir metodun parametresine(Java 8 ile birlikte eklenmiştir.)

    @MyAnnotation
    class MyClass {
        @MyAnnotation
        private int m_val;

        @MyAnnotation
        public void foo(@MyAnnotation int x)
        {
        }
    }
    @interface MyAnnotation {
    }


- Bir annotation içerisinde geri dönüş değeri olan adeta metot bildirimi gibi property'ler bildirebilir.
  Bunlar metod değildir. Bu yüzden herhangi bir parametre bildirilemez.
    @interface MyAnnotation{
        String value(); // bu propertyler default anahtar sözcüğü ile de bildirilebilir
        String value() default "Any";
    }

- Bu property'lerden en az bir tane bile  default anahtar sözcüğü ile belirtilmemiş ise  annotation doğrudan
  kullanılamaz. İlgili property'ye bir atama yapılmalıdır. Eğer hepsi default anahtar sözcüğü ile belirtilmiş ise
  annotation doğrudan kullanılabilir.

   @MyAnnotation
   class Myclass {
       @MyAnnotation(value = "member variable")
       private int x;

       @MyAnnotation(value = "method")
       public void foo(@MyAnnotation(value = "parameter") int x)

   }
   @interface MyAnnotation {
       String value() default "";
       String value2() default "";
   }
   //örnekte ki  value2'nin default'ı kaldırılır ise kodlar error verir.

- Bu default sözcüğünün 3. kullanım şeklidir.
    1-) switch
    2-) interface'lerin default fonksiyonları
    3-) annotation da property


- Bir annotation'ın nerelere konulabileceğini Target annotation'ı ile bildirilebilir.
  Target annotation'ı bir annotation'ının nereye konulacağını belirtir.
  Bu annotation'ın value isimli bir attribute'ı vardır. Bu attribute ElementType enum'ı türünden bir dizi alır.

    @Target(value = {ElementType.TYPE, ElementType.MODULE})
    @interface Entity {

    }
- annotation'larda daha çok varolan annotationlar kullanılacaktır.
- annotation metadata, işaret veya dipnot anlamında kullanılabilir.

- Annotation kendisinden hemen sonra gelen uygulandığı elemanı kapsar.
   @ColumnInfo
   private String m_citizienId,name;// burada ikisini de kapsar.


- annotation 3 şekilde kullanılabilir. Buna Retention denir. Retention bir annotation'ın nasıl kullanabileceğini belirtir.
    1-) runtime da(RetentionPolicy.RUNTIME) // Annotation'ın runtime da kullanabileceğini gösterir.
    2-) class işaretleyebilir. // (RetentionPolicy.CLASS)
    3-) source işaratleyebilir.//(RetentionPolicy.SOURCE)Derleyiciye daha derlemede yapmadan önce yapılacak işlemler.

- @Override annotation'ın retention türü source'dur.(Kullanmamız gereken her yerde kullanılmalıdır.).
  target'ı sadece metotlardır.

- Override annotation'ı bir sınıftan türetilmiş ve override edilmiş metotlar için kullanılır.

------------------------------------------------------------------------------------------------------------------------
                                            19.05.2020
------------------------------------------------------------------------------------------------------------------------

- Annotation'ların elemanın ismi value ise ve işaretleme sırasında yalnızca value elemanına değer verilecekse
  value =  biçiminde yazılmasına gerek yoktur(Bu durum value ismine özgü bir kavramdır.). Eğer value elemanı dışındaki
  elemanlara da değer verilecek ise value = biçiminde yapılması gerekir.

- Deprecated annotation'ı bir elemanın(metot, class vs.) deprecated olarak işaretlenmesi için kullanılır.
- Deprecated annotation'ı bir runtime annotation'dır. Neredeyse bütün türlere uygulanabilir(Annotation'lar hariç).

- Java 9'dan önce bu annotation'ın herhangi bir property'si yoktur.

- Java 9 ile beraber bu annotationa iki tane property eklendi.Bunlardan biri String türünden since, diğeri de
  boolean türünden forRemoval'dır. forRemoval takip ettiği şeyin ileri de silinip silinmeyeceğini belirtir.
  since ise versiyon belirtmek için kullanılır.

- @Inherited annotation'ı da vardır. Eğer taban sınıf bir annotation'a sahipse normalde bu sınıftan türetilen bir sınıf
  ilgili  annotation'a sahip değildir. Ancak bu annotatiton @Inherited annotation'ı ile işaretlenir ise
  türemiş sınıflarda ilgili annotation'a sahip olur. Target'ı sadece ve sadece annotation'dır.

- FunctionalInterface annotation'ı(Java 8 ile eklenmiştir.)
    - Önceden oluşturulmuş bir interface'in fonksiyonel olup olmadığını ilişkin işaret koymak amaçlı kullanılabilir.
    - Bildilendirme amaçlı bir annotation'dır. Türü RunTime'dır.
    - Bu annotation ile işaretlenmiş bir arayüz içerisinde bir ve yalnız bir tane abstract metot olmalıdır. Aksi
      durumda error oluşur.

- SuppressWarnings annotation'ı(warningleri görmezden gel)
    - Aldığı value değerine ilişkin warning'i görmezden gelir. Örneğin CSDArrayList'e ki Object dizi türünden ilgili
      T türüne dönüşümün yapılmasında kullanılmalıdır. Bu annotation kullanılırken programcının emin olması gerekir.
    - Çünkü derleyicinin verdiği hatalar önemlidirler ve dikkate alınmadırlar. Eğer programcı emin ise bu annotation'ı
      kullanmalıdır.


- Java da Generic sınıflar   invariant olduğundan aşağıdaki kod errordur. Generic sınıfları covariant yapmak için
  ? extends sentaksı kullanılır.
    ArrayList<Number> ss = new ArrayList<Integer>();//error
    ArrayList<? extends Number> ss = new ArrayList<Integer>();//covariant haline getirilmiştir. upcasting tarzı durumlar
    için ? extends sentaksı ile kullanılmalıdır(Burada denilmek istenilen Number veya Number'dan türemiş olmalıdır demek
    istenir. Yani bir üst kısıt getirilmiştir. Dikkat bu referansa Integer, Double, BigDecimal, BigInteger sınıfları
    atanabailir.).

- Javada covariant bir generic sınıf yazılamaz. Sınıflar invariant olarak yazılabilir.

- generic bir sınıfa bir kısıt getirilmek istenirse bu kısıt bir sınıftan türetilmek yada bir interface'i implemente
  etmek olacak ise ikisi içinde extends keywordu ile yapılır(Dikkat interface için implements kullanılmaz.).
    class A<T extends <Bir_tür>

- Generic bir sınıfı contravariant yapmak(açılımları downcasting'e uygun hale getirmek için) ? super sentaksı
  kullanılır.
    ArrayList<? super Integer> arrayList; //burada bu arrayList ancak ve ancak Integer veya Integer'a parent class
    larından bir sınıf atanabilir. atanabilir.
    ArrayList<? super Integer> arrayList = new ArrayList<Number>();

- invariant durumlar : atamanın doğrudan yapılabileceği (Java da default generic türü invarant'tır.)

- covariant durumlar : generic türler için atamanın bir upcasting işlemi gibi ypaılabilmesi
    (bir üst sınır verme işlemidir. ? extends [Type] sentaksı ile yapılır. Type'dan türemiş sınıflar atanabilir.)

- contravariant durumlar : generic türler için atamanın bir downcasting işlemi gibi ypaılabilmesi
    (Bir alt sınır verme işlemidir. ? super [Type] sentaksı ile yapılır. Type'ın super class'ları atanabilir.)

- covariant bir generic referans'a ? extends ile belirtilen type sınıfının metodları veya o sınıfın super class'larının
  metodları  kullanılabilir. Bunun dışındaki metodlar kullanılamaz. Örneğin ilgili type Number ise sadece Number
  ve Object sınıfının fonksiyonları kullanılabilir.

- contravariant bir generic referans'a ancak ve ancak ? super sentaksı ile belirtilen sınıf türünden veya bu sınıftan
  türemiş bir sınıftan ekleme yapılabilir. Bunun dışındaki bir türden ekleme yapılamaz. Örneğin iligli type Object ise
  bütün türler eklenebilir. Ancak ilgili type Integer ise sadece Integer sınıfı türünden bir tür eklenebilir.


------------------------------------------------------------------------------------------------------------------------
                                            REFLECTION
------------------------------------------------------------------------------------------------------------------------

- Çalışma zamanı sırasında bir türe ilişkin bilgilere(metadatalara) bakmaktır.

- metadata : bir kavramla ilişkin bilgilere(Bir sınıfın veri elemanları) erişmektir.

- Java da programın çalışma zamanı sırasında her tür için(temel türler dahil) bir Class nesnesi yaratır.
  Bu .class dosyası değildir. Bir Class sınıfıdır.

- Her tür için bir tane Class nesnesi vardır(Singleton).

- Class sınıfı generic bir sınıf olup bir türe ilişkin bilgileri içeren bir sınıftır.

- Reflection işlemleri Class sınıfı ile gerçekleşir. Türün Class nesnesini üretmek için <tür>.class sentaksı kulalnılır.

- Eğer ilgili sınıf bir primitive tür ise aşağıdaki gibi elde edilmelidir. Bu sentaks daki soru işareti any type
  anlamında kullanılır.
    Class<?> clsInt = int.class;

- Eğer ilgili sınıf bir referans türü ise
  Class <Sample> clsSample = Sample.class;
  Class <String > clsString = String.class;

- Class sınıfının static forName metodu ile türü String olarak elde etmemizi sağlar.
    Class<?> clsSample = Class.forName("org.csystem.app.Sample"); //ilgili paketteki Sample sınıfını getir.
    Dikkat eğer sınıf bulunamaz ise checked exception olan ClassNotFoundException nesnesi fırlatılır.

- Class sınıfının getName fonksiyonu ilgili sınıfın ismini nitelenmiş bir şekilde verir.

- Object sınıfının getClass metodu ile referansın dinamik türüne ilişkin Class referansı elde edilir.

- Class sınıfının getDeclaredXXX(Methods, Fields ...) metodu ile türe ilişkin elemanlarına erişim belirleyiciden bağımsız
  erişilebilir. Bu metod taban sınıfın metoduna erişemez.

- Sınıfın getXXX(Method,Field,Annotation) metodu ile türe ilişkin sınıfın  ve taban sınıflarının yalnızca public bölümündeki
  elemanlarına erişilir(taban sınıfların sadece public bölümüne  erişilir. protected bölümüne erişilemez.).


------------------------------------------------------------------------------------------------------------------------
                                            23.05.2020
------------------------------------------------------------------------------------------------------------------------
- Reflection için kullanılan sınıfın herhangi bir ctor'una erişim Class sınıfının getDeclaredConstructor metodu ile
  sağlanabilir. Bu metod generic bir sınıf olan Contructor sınıfını geri döndürür. Eğer bulunamaz ise
  NoSuchMethodException hatası fırlatır.
    Class<?> cls = Class.forName("org.csystem.app.Sample"); // checked bir exception fırlatır.
    cls.getDeclaredConstructor();// eğer parametreli bir ctor alınmak istenirse ilgili ctor'un parametre'lerinin
    class nesneleri verilmelidir.
    Eğer Sample sınıfının int, double parametrelerine sahip bir ctor'u var ise aşağıdaki gibi yazılır.
    Constructor<?> intDoubleCtor = cls.getDeclaredConstructor(int.class, double.class);
    intDoubleCtor.setAccesible(true); // Eğer ki ctor private bildirilmiş ise bu kod yazılmadan çağrılması errordur.
    intDoubleCtor.newInstance();// eğerki constructor erişilebilir ise bu kodlar çağırılır. Eğerki erişilebilir

- Class sınıfının getDeclaredXXX(Method, Field ...) String parametreli methodları sınıfın erişim belirleyicisinden
  bağımsız ilgili  elemanına erişmemizi sağlar. Eğer verilen String parametresine uygun bir eleman bulunamaz
  ise checked exception throw eder.
- Class sınıfının getXXX(Method, Field ...) String parametreli methodları ilgili türün ve taban sınıflarının public
  bölümündeki elemanına erişmemizi sağlar. Eğer verilen String parametresine uygun bir eleman bulunamaz  ise CHECKED
  exception throw eder.

- Yukarıdaki iki durum içinde  Erişilen elemana göre(eğer eleman Method ise Method sınıfı, field ise Field) o sınıf
  türünden nesne elde edilir.
    Class<?> clsSample = Class.forName("org.csystem.app.App");
    Class<Sample> clsSample = Sample.class;//Eğer tür biliniyor iseşeklinde yazılabilir.
    Constructor<?> ctor = clsSample.getDeclaredConstructors(/*Parametrik yapıya uygun class nesnesi verilmelidir.*/);
    Constructor<Sample> intCtor = clsSample.getDeclaredConstructors(int.class);//int parametreli ctor istenmiştir.
    Field field = clsSample.getDeclaredField("x");//eğer  ilgili method yok ise checked error fırlatılır.
    Method method = clsSample.getDecleradMethod("getX", int.class, double.class);//eğer ki sınıfın int ve double
    parametreli getX methodu var ise elde edilir yoksa error oluşur.
- Elde edilen bir Method, Field yada Ctor .... sınıfın içinde private bildirilmiş ise ve kullanılması gerekiyor ise
  bu sınıfların setAccessilbe(true); şeklinde çağrılması gerekmektedir. işlem bittikten sonra setAccessible yeniden false
  yapılmalıdır.

- Elde edilen tür bir ctor ise ve yeni bir nesne yaratılmak istenir ise tür Constructor sınıfının non-static ctor'ı sınıf
  any Type ile açılmış(Yani Constructor<?>) ise new Instance methodu geriye Object döndürür. Type Cast yapılması zorunludur.

- Elde edilen tür bir Method ise ve sınıfın ilgili metodu çağrılmak istenir ise Method sınıfının non-static invoke metodu
  ile bu işlem yapılır. Ne olursa olsun non-static bir method için ortada bir nesne olmak zorundadır.
  invoke methodunun birinci parametresi ilgili sınıf türü ne ise o sınıf türünden bir referans ister. Eğer ki method
  static bir method ise bu parametreye null geçilebilir.


- Singleton design pattern'i Reflection ile delinebilir. Ancak enum türünden reflection ile elde edilemez. Enum türünden
  sadece enum sabitlerinden kaç tane  var ise program boyunca o sayı da nesne vardır.

- constructor kodları ara koda yazılırken init ismi ile yazılır.

- @Deprecated annotation'ı Inherited bir annotation değildir.

- DynamicLoadingApp uygulaması yapıldı.
    - Uygulama çalışırken SampleClasses modülündeki .class dosyaları  uygulamanın çalıştığı modüle( yani out'un altındaki
      production'ın altındaki 004-SampleDynamicLoading modülüne eklendi);

- GameObject örneği yapıldı(Dikkatlice incelenmesi gereken bir örnektir).

- Method sınıfının invoke methodu
    1. parametresi -> ilgili metodun hangi referans ile çağıralacağı(static bir metot ise null geçilebilir.)
    2. parametresi -> ise Object ... args'dır. Metota geçilecek argümanlar içindir
    m.invoke(gameObject,other); // gameObject.onCollision(other);



------------------------------------------------------------------------------------------------------------------------
                                            24.05.2020
------------------------------------------------------------------------------------------------------------------------

- Generic'ler de Programlama da 3 farklı yaklaşım vardır
    1- C++'da ki gibi(Derleyici compile time'da kod yazar)
    2- C# da ise her açılım için farklı bir tür vardır(Derleyici ayrıca bir kod yazmaz).
    3- Java da ise her açılım için tek bir tür vardır().

- Generic sınıflar'ın tek bir tür olduğunu ilgili sınıfın farklı açılımlar için getClass fonksiyonlarını çağırıp
  karşılaştırma yapılarak ispatlanabilir.

------------------------------------------------------------------------------------------------------------------------
                                            Collection lara yönelik interface'ler
------------------------------------------------------------------------------------------------------------------------

--- iterable interface'i
- Java da tüm collection sınıfların başında yer alan özel bir interface vardır. Bu interface'in ismi iterable'dır.

- Herhangi bir veri yapısının datalarının nasıl tutulduğundan BAĞIMSIZ OLARAK dolaşabilmeye iterator pattern'i denir.
  (C++'ın STL'i tamamen iterator kalıbına dayalıdır.)

- iterable olmak iterator biçiminde kullanılabilir olmak anlamına gelmektedir. Bu interface java 5 ile eklenen generic
  bir interface'dir. Java 5 ile beraber for-each döngü deyimi de eklenmiştir.

- Bir sınıfın foreach döngü deyimi ile dolaşılabilir olması için sınıfın iterable interface'ini desteklemesi gerekir.

- iterable sınıfının yalnızca bir adet abstract  metodu vardır. Metodun ismi iterator'dur. parametrik yapısı aşağıdaki
  gibidir.
    Iterator<T> iterator();

- Iterator interface'i(Java 1.2) Iterable interface'inden  daha önce implemente edilmiş generic  bir interface'dir.

- Iterator<E> interface'inin iki tane abstract metodu vardır.Bunun dışında metodları vardır.
    boolean hasNext();
    E next();

- Java 8'den önce üç tane abstract metodu vardı.
    void remove(); //3. fonksiyon remove idi.

- Java 5'den önce yani iterable interface'inden önce(Yani foreach döngüsü yokken) iterator dolaşımı şu şekilde
  yapılmaktaydı.

  ArrayList<Integer> list = new ArrayList();
   Iterator<Integer> iter = list.iterator(); // iterable'dan önce Iterator döndüren iterator fonksiyonu vardı.
   while(s.hasNext()) {
        int val = s.next();
   }

- foreach always applicable'dır.

- foreach kodunun karşılığı tam karşılığı şağıdaki gibidir.
    ArrayList<Integer> list = new ArrayList();
   for(int val : list) {
        System.out.printf("%d ", val);
   }

   {
       Iterator<Integer> iter = list.iterator();

       while (iter.hasNext()) {
           int val = iter.next();

           System.out.printf("%d ", val);
       }
   }

- burada hasNext() metodu bir sonraki elemanın olup olmadığını kontrol eden metoddur.

- next() metodu ise bir sonraki elemanı geri döndüren metoddur(Eğer eleman yoksa ve çağrılmış ise NoSuchElementException
  fırlatılır.). next fonksiyonu aynı zamanda iterator'de ilerlemeyi sağlayan fonksiyondur.Nasıl yapıldığı o kodu
  implemente eden kod belirler(Örneğin yazılan IntRange'de belirtilmiştir).

- NOT : java'da iterable olabilmek için sınıfın iterable interface'ini implemente etmek yada iterable türetilmiş bir
  interface'i implemente etmek zorunludur.

------------------------------------------------------------------------------------------------------------------------
                                            30.05.2020
------------------------------------------------------------------------------------------------------------------------

- Java'da Iterable'dan sonra Iterable'dan türetilmiş generic Collectin arayüzü vardır. Collection'ının da
  iterable'dan gelen iterator metodu dışında bir çok abstract metodu vardır.

- Java'da her veri yapısı collection değildir(Map interface'ini impelemente sınıflar).
- Collection interface'inden türemiş bazı ana interface'ler vardır. Bunlar
    1 - List (ArrayList, Vector) //aralarında öncelik sonralık ilişkisi vardır.
    2- Set // Bir küme ilişkisi vardır.
    3- Queue




- Collection sınıfının önemli metodları
    - add(E e)
    - addAll(Collection<? extends E> c); // bir Collection'dan başka bir collection'a aktarım yapmamızı sağlar.
    - void clear();
    - boolean contains(Object o)
    - isEmpty()
    - iterator()
    - remove()
    - removeAll(Collection<?> c)
    - size()

- Collection arayüzlerinin birbirlerine veri aktarma işlemi yapmak için çok rahat kullanılabilir(addAll ve constructor
  içerisinde).
- ArrayList'in Collection sınıfını alan bir ctor'u da vardır.
- Data sınıfları için genel olarak equals metodu yazılmalıdır. Bir sınıfın yazı karşılığı varsa böyle sınıflara
  data sınıfları denir.

- Data sınıflarının Object'ten alınan ve genellikle override edilmesi gereken üç önemli fonksiyonu vardır.
    - public toString()
    - boolean equals(Object o)
    - int hashCode(); // hashCode metodu özellikle Hash sınıfları kullanılmasıı gerektiğinde implemente edilmelidir.

- Collection interface'inden türetilmiş list interface'inin öncelik sonralık ilişkisinden dolayı index kavramı vardır.
  Bu interface'i implemente eden sınıflar da index ile veri yapısındaki i. indexteki elemana erişmek mümkündür.

- Collection'lar içerisinde index parametresi dönen yada index parametresi ile çalışan metodlar List interface'ine
  aittir(Bu sınıflar, ArrayList, Vector, Stack).
    1- get(int index);
    2- indexOf(Object o);
    3- add(int index, T elem);


- indexOf metoduna geçilen parametre null değil ise list'in elemanları için karşılaştırmayı veri yapısındaki sınıfa
  ait equals metodu ile yapar. eğer equals metodu override edilmemiş ise taban sınıflara bakar bulunamazsa en son
  Object sınıfının equals metodunu çağırır.

- List interface'i indexOf metodu için özellikle Objects(Dikkat Objects sınıfı değil) sınıfının equals metoduna ilgili
  parametrelerin geçilerek overrride edilmesini önerir. indexOf metodunun parametresi Object türündendir.
  T türünden değildir.

- Objects sınıfının equals metodu eğer ilgili referanslardan ikisi de null ise true, sadece biri null ise false, aksi
  taktirde birinci parametreye gelen sınıfın equals metoduna ikinci parametreyi geçer(equals metodunun override edilmesi).
  bu yüzden önemlidir.

- Arama yapan collection sınıfları mutlaka ve mutlaka equals metoduna bakarlar.

- Donald Knuth birden fazla return deyimi içeren fonksiyonların içinde tek bir değişken tutulup fonksiyon bloğunun sonunda
  dönüş yapılmasının ara kod için daha iyi bir çözüm olacağıdır.

- contains metodu'da indexOf'a bağlu olarak true yada false döner. Eğer değer >= 0' sa true aksi değerde false döner.

- Collection sınıfların hepsi sınıfta bir değer aranacağı zaman bunu tuttukları değerin equals  metoduna bakarak
   yaparlar. Burada sadece Hash ile başlayan sınıflar, ayrıca hashCode metoduna bakarlar.
- Objects sınıfı java'nın util paketi içerisindedir.

- Data sınıflarına yazılması gereken metodlar.
    1-toString
    2- equals
    3- compareTo(Comparable<T> interface'inden türetilmiş olması lazım)
    4- hashCode -> hash sınıfları için yapılması gerekir.


- Vector sınıfı
    - capacity değeri default olarak iki katına çıkacak şekilde tasarlanmıştır. Nedeni ise O log2^n'e yakınsanmak içindir.
    - burada bu artım miktarını değiştirmek mümkündür. Ancak bu durumda bir artırma işlemi söz konusudur çarpım söz
      konusu değildir(ArrayList'in artırma işlemi kesin belli değildir ancak 1,5 katı gibi düşünülebilir.).

- capacity'nin arttırma miktarına bir argüman geçilirse o miktar ile toplama yapılarak artırılır.
- vector hemen hemen ArrayList gibidir. Thread Safe için bir kötü yanı vardır.
- Ancak vector çok fazla özelliğe sahip bir sınıftır(Solid'in Single responsibility'sini deler.).
- veri yapısı olarak ArrayList veya vector arasında kalınır ise ArrayList seçilmelidir.

------------------------------------------------------------------------------------------------------------------------
                                            31.05.2020
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
                                            List interface'ini implemente eden Collection sınıflar
------------------------------------------------------------------------------------------------------------------------

- adapter sınıf : bir sınıftan türetilmiş ve sınıfın başka bir işlem içinde kullanılmasını sağlayan sınıflardır. O sınıf
  ile istenilen işlem yapılmazken sınıfa yapılan eklemeler ile istenilen işlemin yapılması sağlanır.
   Stack sınıfı bu anlamda Vector'den türetilmiştir.

- stack veri yapısının en tipik örneği editörlerin undo sistemidir. Silme yaptıkça bunları ilgili veri tabanına ekler.
  Ctrl + z ile bu veri tabanından çıkarma yapar.

- Stack sınıfıın metodları
    - eleman ekleme kalıbı : push
    - eleman alma kalıbı : pop // son elamanı alır, ve alınan elemanı siler.
    - peek metodu();// // son elemanı alır. silme işlemi yapmaz.
    - search(); // yukarıdan aşağıya doğru stack'i arar. en son eklenen elemanın indexi 1. indekstir. Aslında
      search ile bulunan indeksteki elemanı elde etmek için stack.get(stack.length() - index); şeklinde yapılmalıdır.
      Dikkat bu işlem implemente edilmek istenirse indexOf'a göre değil lastIndexOf'a göre yapılır.

- stack sınıfının isEmpty metodunun yanı sıra empty metodu da vardır.
- stack sınıfının pop metodu eğer eleman yok ise EmptyStackException hatası fırlatır.
- Arada ki bir indekse sık sık eklemenin yapıldığı algoritmalar da list yada stack gibi bir veri yapısının kullanılması
  çok yanlış bir tercihtir. Algoritmanın seçimi özellikle önemlidir.


- LinkedList(Bağlı Liste)//Doubly linked listtir.
    - Singly linked list Java da implemente edilmemiştir.
    - doubly linked list implemente edilmiştir.

- İçerisinde
    Node referansı vardır.
-DoublyLinkedList hem List'i hemde Deque interface'ini implemente etmiştir(Deque interface'i ile başına ve sonuna eleman
 eklenebilen elemanlardır. ArrayList Deque değildir çünkü başa eklenme yapılamaz.).

- Araya ekleme yapmak çok hızlıdır.(ArrayList gibi sınıflar da araya ekleme yapmak için kaydırma yapılır.)
- Diziden daha fazla yer kablar. Çünkü içerisinde üç adet referans tutulur.
- Okuma yapmak ise O(n)'dir(ArrayList'te ise araya erişim O(1)'dir.).
- capacity değeri yoktur.

- sınıfın poll ve pollFirst metodu baştan eleman çekilmesini sağlar ve çekilen elemanı siler. poll ve pollFirst
  metodu eleman kalmadığında null değeri döner. Veri yapısı null'da tutabilir. Bu durumda geri dönüş değerinin
  null olup olmamasının durumuna göre bir kontrol yapılması yanlış bir durumdur.

- Yukarıdaki bahsedilen sorunun çözüm yöntemi null tutulmanın da gerekli olduğu bir LinkedList sınıfında Sınıfın
  T açılımı değil Optional T(LinkedList<Optional<T>>  instead of LinkedList<T> ) açılımının kullanılmasıdır.

- eğer dönecek bir eleman yok ise null değeri döner. Veri yapısına null eklenmesi durumuna dikkat edilmelidir.
  null eklenmesini gerektirecek sınıflar da sınınıfın T açlımı değil Optional<T> açılımı kullanılabilir. Gereken
  yerde de null eklemek yerine empty bir Optinal eklenebilir.

- Collection sınıfının toArray metodu
    1- Object [] toArray(); // ilgili Collection sınıfının elemanlarını geçilen diziye aktarır. dizinin uzunluğu o
       an ki collection'ın içinde tutulan elemanlar kadar olmalıdır.
    2- <T> T [] toArray(T [] array);  // verilen T türünden diziyi collection'ın elemanları ile doldurur.

    ikisinin arasındaki fark 2.si için tür güvenliği söz konusudur. ilki için cast işlemi yapılmalıdır.Compile time için
    tür güvenliği söz konusu değildir.

 - Öncelik sonralık ilişkisi olan collection sınıfı list interface'ini implemente ederler.
------------------------------------------------------------------------------------------------------------------------
                            Set interface'ini implemente eden Collection sınıflar(Küme tarzı collection'lar)
------------------------------------------------------------------------------------------------------------------------

- Bu tür collection'lar için elam tekrarına izin yoktur.Kesin kuraldır.
- elemanların collection içinde olup olmadığının kontrolü equals metodu ile yapılacaktır.
- bazılarında elemanlar sıralı(yani sort edilmiş şekilde) eklenir bazılarında sranın önemi yoktur.

- başında hash ismi geçen bir collection hashcode ile çalışır. Başında hash olan bir collection eşitlik kavramına
  iki şekilde bakar. Hızlı olması için kullanılır. Arama ve Ekleme de çok hızlı çalışır
    1- equals
    2- hashCode'ları da aynı olmalıdır.//hashCode int türden bir değer. Object'in üçüncü önemli metotudur.
  yukarıdaki eşitliklerin ikisinin de sağlanması durumunda HashSet sınıfında bir elemandan bir tane olabilir.

- hash tarzı collection'lar için kullanacak sınıflar da hashCode metodu override edilmelidir.
- hashCode sınıfında bir objeden bir tane olabilmesi için, hem hashCode hemde equals metodunun override edilmesi gerekir.

- HashSet sınıfı null tutabilen bir sınıftır.
- Sıranın önemsiz olduğu bir durum söz konusu olduğunda her zaman hashSet sınıfı treeSet sınıfı yerine tercih edilmeli
  dir.

- TreeSet sınıfı sıralamayı açılımda kullanılan sınıfın compareTo metodunu çağırarak yapar.Eğer açılımda kullanılan
  sınıf comparable'ı implemente etmemiş ise ve default ctor ile nesne yaratılır ise exception throw edilir.

- Bir tür sıralanacak ise yani iki farklı objesinin arasında büyüklük küçüklük ilişkisi var ise Comparable interface'ini
  implemente etmelidir. Bu sıralama default olarak küçükten büyüğe olacak şekilde yapılır. Küçükten büyüğe sıralamaya
  natural sort order denir. Arrays sort, TreeSet'in sort'unda default kullanılan işlem natural sort order'dır.

- TreeSet sınıfı ctor'da herhangi bir koşul verilmez ise sıralamayı küçükten büyüğe doğru sıralar.

- TreeSet sınıfında da bir elemandan sadece bir tane bulunabilir(TreeSet sınıfı hashCode metoduna bakmaz).

- Comparable interface'i curiously recurring template pattern (CRTP)'e göre implemente edilmiş bir interface'dir.
  Hangi sınıf'tan açılır ise compareTo metodunu ona göre implemente edilmesi gerekir.

- compareTo metoduna göre yapılan bir sıralama da çağıran çağrılandan küçük ise negatif döner.Eğer doğal sıralama
  yapılıyorsa ilgili elemanı sola atar.

- TreeSet sınıfının bir tane daha constructor'ı vardır. Bu constructor sayesinde sıralamayı büyükten küçüğe yada
  Comparable sınıfını implemente etmemiş bir sınıfı dahi TreeSet içerisinde kullanabiliriz.

- Bu ctor Comparator(Sıralayıcı) interface'ini ister. Doğası functional'dır. Gerçekte iki tane abstrac method'u olmasına
  rağmen(biri compare, diğeri equals) methodlardan biri olan equals object'ten geldiği için bu method abstract method
  sayısına eklenmez.

- Comparator interface'ine geçilen lambda ifadesinin parametrik yapısındaki sıralama önemlidir. Parametrik yapıdaki
  sıraya göre büyüklük ve küçüklük ilişkisi belirlenir. eğer metodun geri dönüş değeri negatif ise parametrik yapıdaki
  sıraya göre sol taraftaki değer daha küçük, pozitif ise sol taraftaki değer daha büyük, 0 ise iki değer birbirine
  eşittir.

- burada örneğin comparable olan Rational sınıfı için
    TreeSet<Rational> rationalTreeSet = new TreeSet<>((r1,r2) -> r2.compareTo(r1));
     compareTo methodunda fonksiyonun sol parametresine gelen değişken sağına gelen değişkenden küçük ise negatif döner.
     Yukarıda ise fonksiyonu parametrik yapısı aynıdır. Ancak fonksiyonun çağırma sırası değiştiği için sanki küçük
     olan nesneyi büyükmüş gibi büyük olan nesneyi de küçükmüş gibi göstermemizi sağlar.

- Yukarıda açıklanan örneği Comparator interface'inin reverseOrder methodu ile de yapılabilir. Bu methodu geri dönüş
  değeri Comparator interface'ini implemente eden bir sınıf'dır. Bu fonksiyonun çağrılması için bizim verdiğimiz türün
  Comparable olması zorundadır.
    TreeSet<Rational> rationalTreeSet = new TreeSet<>(Comparator.reverseOrder());

- Comparator sınıfı sayesinde ayrıca Comparable olmayan nesneleri de TreeSet'te tutmamızı sağlayabiliriz.
  Bunun için'de lambda ifadeleri kullanılabilir.
  TreeSet<Complex> complexes = new TreeSet<>((z1, z2) -> Double.valueOf(z1).compareTo(z2));
  // Burada  Comparator interface'i lambda ifadesi ile implemente edilmiştir.

- Comparable olmayan bir nesne'yi de Comparatar interface'ine vererek compare işlemi yapılabilir.
------------------------------------------------------------------------------------------------------------------------
                                            06.06.2020
------------------------------------------------------------------------------------------------------------------------

- Set collection'ları daha çok bir eleman var mı yok mu bu duruma bakan collection'lardır.
- HashSet sıralama önemsizdir(hashCode ve equals metoduna bakar).
- TreeSet sıralama önemlidir(Sadece equals metoduna bakar. Açılıma verilen sınıf ya
  Comparable olmalı, comparable değil ise construnctor'da Comparator interface'ine lambda geçilmelidir.).

-Comparator reverseOrder(static) methodu
    - Comparable olan bir nesneyi büyükten küçüğe sıralamak için kullanılırç

- Comparator arayüzü ile karşılaştırmanın nasıl yapılabileceğibelirtilir.
    TreeSet<Integer> treeSet = new TreeSet<>((i1, i2) -> i1.compareTo(i2)); // büyükten küçüğe
    TreeSet<Integer> treeSet = new TreeSet<>((i1, i2) -> i2.compareTo(i1)); // küçükten büyüğe

- aşağıdaki static fonksiyonlar genel olarak comparable olmayan nesneler için kullanılır.


- Comparator sınıfının default reversed metodu.
    - Comparator interface'ine verilen lambda ifadesine göre değil onun tersine göre sıralama yapmayı sağlar.
      Comparator<Complex> comparator = (c1,c2) -> Double.valueOf(c1.getNorm()).compareTo(c2.getNorm());
      TreeSet<Complex> treeSet = new TreeSet<>(comparator.reversed());//Norm'a göre küçükten büyüğe doğru yapar.

- Comparator sınıfının static comparing ve comparingXXX metodları(Geri dönüş değerleri comparator'tür.)
    comparingXXX(comparingDouble, comparingInt, ComparingLong);
        - Temel türlere ilişkin işlemleri yapmak için kullanılır.


    comparing(Function<? extends T, ? extends U> keyExractor);// geçilen lambda ifadesine göre bir değer üretir.

- Comparator<Complex> comparator = (c1,c2) -> Double.valueOf(c1.getNorm()).compareTo(c2.getNorm());
                                    //Comparator.compareDouble(z -> z.getNorm());
                                    //Comparator.compareDouble(Complex::getNorm);//tam anlamıyla functional programming
  TreeSet<Complex> treeSet = new TreeSet<>(comparator.reversed());//Norm'a göre küçükten büyüğe doğru yapar.

------------------------------------------------------------------------------------------------------------------------
                                            Map collection'ları
------------------------------------------------------------------------------------------------------------------------

- Javada Map<K,V> isimli arayüzünü destekleyen collection sınıfları vardır. Dikkat Map bize göre bir collection'dır.
  Collection'dan yada herhangi bir arayüzden türetilmemiştir. Map interfaceini destekleyen sınıflara sözlük tarzı
  collection sınıflar denir. Key Value prensibi vardır.

- Bir anahtara karşılık Bir değer tutulur(Buradaki değer eğer bir ArrayList ise bitden çok değer tutulabilir).
- bir anahtara yeni bir değer verilirse eski değer silinir. bu işlem put metodu ile yapılır. Put metodu silinen değeri
  geri döndürür(Eğer ki ekleme yapılmadan önce ilgili anahtar boş ise null döner.).

- Hash sınıfları null değeri de tutabilir. Bir keyin var olup olmaması constainsKey metodu ile yapılır.
- Burada anahtarlar Set sınıfları ile tutulur. Eğer sınıf HashMap ise anahtar HashSet ile, eğer sınıf TreeMap,
  ise TreeSet anahtar'lar treeSet ile tutulur.

- HashMap sınıfları için karşılaştırma olarak(hashCode ve equals metoduna bakılır.)
- TreeMap sınıfları için anahtar karşılaştırması(Açıldığı sınıfın equals'ı ile yapılır.
  ile tutulur.
  class HashMap<K,V> {
   Pair<HasMap<K>, V> keyVals;

  }

- Map intterface'inin keySet metodu bütün kullanılan anahtar değerlerini geri döndürür.

- get(Object o) metodu da sınıfın ilgili key'ine karşılık gelen bir value var ise onu döndürür.

- HashMap bir key için bir value tutar. Ancak açılımnda HashMap<K,V> yerine HashMap<K,ArrayList<V>> kullanılır ise
  bir key için birden çok değer tutulmaını sağlar.

- TreeMap sınıfı ile HashMap arasındaki fark TreeMap sınıfı anahtarları sıralı tutar. Açıldığı türün yalnız equals metoduna
  bakar

- Map sınıfının values metodları key'lere karşılık tutulan bütün değerleri döndürür..

- Java'da bir program içinde aynı yazıların hashCode bilgileri eşittir(Farklı derleyiciler de farklı değerler olabilir).
  Ancak bu durum derleyiciden derleyici değişebilir. Bu yüzden farklı derleyicilerde o derleyeicide üretilen hashCode'un
  aynısı üretilmeyebilir. Ancak  aynı string nesnesi için gene o derleyici içinde aynı hashcode üretilir(X derleyicisinde
  üretilen hashCode ile Y derleyicisindeki farklı olabilir. Ancak X derleyicisinde aynı string nesnesi için aynı hashCode
  değeri üretilir.). C#'da aynı derleyici de program her çalıştığında farklı sonuçlar verir. Java'da aynı derleyici de
  aynı sonucu verir.

------------------------------------------------------------------------------------------------------------------------
                                            13.06.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            Stream Api
------------------------------------------------------------------------------------------------------------------------

- Java da ki fonksiyonel programlamaya yönelik library'lerdir.(Aslında bunlara yeni nesil iterator'ler de denilebilir.)

- Java 8 ile birlikte eklenen fonksiyonel programlamayı destekleyen ve fluent kalıbı ile çalışan stream api'ler eklendi.

- Stream bir generic interface'dir(açılımı T'dir.).

- Çok kullanıldıkları için temel türler için kullanılan IntStream, LongStream,DoubleStream interface'leri vardır.


- Stream interface'inin bir çok abstract metodu vardır. Stream interface'inin implementasyonunu biz yapmayız.
  Collection interface'inin default stream methodu bir Collection sınıfından bize stream interface'ini implemente etmiş
  bir Stream referansı döndürür.

- Stream interface'ini biz genel olarak implemente etmeyiz. Biz stream'i implemente etmiş sınıfları kullanılırız.
- Stream'i implemente etniş bir sınıf

- Stream'in bir çok yararlı callback alan metodu vardır. Bu metodlar lambdalarla çalışabilecek şekilde implemente edilmiştir.

- Stream'lar elimizde dizi veya collection var ise çok daha anlamlı şekilde çalışır.

- Stream api'ler  fluent kalıbına dayandığından kaynaklı bir çok fonksiyonunun geri dönüş değeri Stream<T>'dır.'


- IntStream'in static range ve rangeClosed metodu
    - range metodu(begin,end) [begin,end);//aralığındaki sayılardan oluşan bir stream döndürür.
    - rangeClosed metod(begin,end) [begin,end] aralığındaki sayılardan oluşan bir stream döndürür.


- IntStream'in static generate metodu
    - bir supplier(Yani parametresiz int değer döndüren bir lambda ister.). Eğer ki IntRange'den sonra limit fonksiyonu
      çağrılmaz ise generate promgram patlayana kadar değer üretir.

    - generate methodunun görevi supplier'dan aldığını sürekli olarak generate eder. Limit koyarak n tane rastgele
      üretilmiş sayı elde edilir.



- Stream'lerde son fluent kalıbının son çağrılan metodu çalıştığında arka plandaki döngü oluşur. Örnek olarak

    list.stream().filter(s -> s.length > 5 ).forEach(System.out::println);
    // burada filter için ayrı forEach için ayrı bir döngü yapılmaz. En son kod forEach olduğu için forEach
       çalıştığı zaman arka plandaki döngü yaratılır. Kodunun arka planda aşağıdaki şekilde yazıldığını düşünebiliriz.
       for (String s : list)
       {
            if (s.length > 5)
                System.out.prinltn(s);// kod bundan çok daha efektif yazılmış bir kod olabilir.
       }



-- Aşağıdaki metodlar bütün stream arayüzleri için geçerlidir.

- forEach metodu
    - Consumer interface'i ister.
    - forEach metodu çok kullanıldığı için Iterable interface'ine de eklenmiştir.(default bir metoddur.)

- filter
    - içine bir predicate alır. stream arayüzünün tuttuğu verilerden koşula uyanları döner.

- count metodu
    - bir Stream arayüzünde tutulan veri sayısını döndürür. geri dönüş değeri long'dur.

- allMatch metodu
    - aldığı predicate'e Stream'de tutulan bütün verilen uyuyor ise true döner.

    if (products.stream().allMatc(s -> s.getStock() > 0))
        sout("bütün ürünler stokta vardır.")
     else
        products.stream().filter(s -> s <= 0).forEach(System.out::println)// stokta olmayan ürünleri yazdırır.

- anyMatch metodu
    - aldığı predicate'e Stream'de verilerden bir tane bile uyan varsa true döner.
    if(products.stream().anyMatch(s -> s.getStock() <= 0)) // stokta ürün yoktur.
        products.stream().filter(s -> s <= 0).forEach(System.out::println)//stokta olmayan ürünleri yazdırır.

- noneMatch metodu
    - aldığı predicate'a Stream'deki verilerden hiç biri uymuyorsa true döner.
            if(products.stream().anyMatch(s -> s.getStock() <= 0)) // true ise bütün ürünler stokta vardır..
                products.forEach(System.out::println); // bütün ürünleri yazdırır.

- allMatch ve noneMatch'e atanacak lambda ifadesi birbirinin tam zıttı olursa aynı sonucu verirler.
    products.stream().allMatch(p -> p.getStock > 0);//Ürünlerin hepsi stokta var ise(verdiğimiz predicate ile eşleşme vardır.)
    products.stream().noneMatch(p -> p.getStock <= 0);// Ürünlerinin hepsi stokta var ise.
    (Verdiğimiz predicate ile eşleşmeme durumu)


- stream sadece bir grup veriyi temsil eder.

- IntStream'in of methodu
    - Parametresi int ... val türündendir.
    - Bu parametreye bir dizi yada birden çok int değer geçilebilir.

- Java 8'den itibaren factory metodlar valueOf ile değil of ile isimlendirilmiştir.

- of metodları elimizde bulunan bir diziyi sarmalayıp stream elde etmemizi sağlar.

- temel türden(int, long, double) dizilerden ilgili XxxStream interface'lerinin of metodu ile sarmalanabilirler.

- Arrays'in stream metodu da kendisine verilen T türünden diziler için Stream<T> açılımını primitive türler için
  ilgili IntStream, LongStream, DoubleStream'den hangisi uygunsa ona döner.


- stream bir dizi yada öncelik sonralık ilişkisi olan bir collection olmak zorunda değildir. Stream'in sadece
  bir grup veriyi temsil ettiği belirtebiliriz.

- findFirst metodu özellikle web servislerinde çok kullanılır.
    - stream'da tutulan ilk veriyi döner. Geri dönüş değeri optional'dır.
    - Optional olmasının nedeni stream'in boş olması yada findFirst'ten önce bir filter metodu yapılmış ve
      bunun sonucunda stream'in boş olmasıdır.


---- stream api'lerde dönüşüm(Bir stream'den başka bir stream elde etme ---
- dönüştürme işlemleri map metodları ile yapılır

- map metodları -> dönüştürme işlemi için kullanılır. Bir stream'dan başka bir stream nesnesi elde edilmesini sağlar.



- Stream'in map metodu generic bir stream elde edilir. map metodundan bir IntSream elde edilemez. Ancak ve ancak
  Stream<Integer> açılımı elde edilebilir

- Generic bir Stream'den  IntStream DoubleStream, LongStream elde etmek için mapToInt, mapToDouble, mapToLong metodları
  kullanılır.

- kısace map metodları aldığı T türünden bir Stream'i Stream'in R  açılımını geri döndürür.

- map metodunun parametresi de Function olduğu için(Function<T,R> ) Stream'in<R> türünü döndürür.

- filter yada forEach metodlarında yeni bir stream türünü geri döndürmez.
    products.stream().filter(p -> p.getStock() > 0).forEach(System.out::println);//burada her method sonunda yeni
    bir stream nesnesi üretilmez.

- Ancak map metodu yeni bir stream döndürür. Aşağıdaki map metodu yeni bir stream referansı döndürür.
    products.stream().filter(p->p.getStock() > 0).map(Product::getName).forEach(System.out::println)

- Kısaca map metodları(Bir çok programlama dilinde map ve reduce bu şekilde isimlendirilmiştir.) a türünden b türüne
  dönüşüm yapılmasını sağlar. A türünün B türüne dönüşmesini sağlayan bir metodu veya boxing, unboxing mekanizması
  olmalıdır. Ayrıca aldığı A türü üzerinde bir işlem yapıp yeniden A türüne de dönebilirler.



- Stream'in of metodu
    - IntStream'in of metodu int [] a bir diziyi sarmalamak için kullanılır.
    - Stream'in of metodu ise T türünden bir diziyi sarmalamak için kullaınırız

- Bir Stream üzerinde belirli bir işlem yapan api'lerde vardır. reduce metodu bu api'lerden bir metodudur.

- reduce metodu(Hem Stream için, hemde XxxStream için geçerlidir.)
    - Bir Stream üzerinde belirli bir işlem yapıp bir sonuç üretir.
    - reduce metodlarının parametresi BinaryOperator'dır(IntStream için IntBinaryOperator).
    - BinaryOperator interface'i T türünden iki tane referans alıp bu referanslar'ın sonucunu üretir.
      Örneğin

    - reduce metodu iki farklı şekilde yazılır(2 farklı overload'ı vardır.).
        1- Optional<T> reduce(BinaryOperator<T> operation); // boş bir Stream ile kullanılabileceğinden Optional döner
        2- T reduce(T identity,  BinaryOperator<T> operation); // boş bir Stream ile kullanılması sonucu identity'yi
           geri döner.

        - reduce'ın yukaridaki metodları XxxStream interface'leri için uygun şekilde yazılmıştır.
            1-OptionalInt reduce(IntBinaryOperator operation)
            2-int reduce(int, identityIntBinaryOperator operation)

    -  reduce(aşağıdaki örneğe göre anlatılacaktır) metodunun birinci versiyonunda Stream'in birinci elemanını alıp r
       parametresine atama yapılır. Her bir adımda sonuç e'ye sıradaki eleman atanır. yapılan işlem sonucu r'ye atanarak
       devam eder. Stream boş olabileceğinden kaynaklı geri dönüş değeri Optional'dır.
        Stream.of(cities).reduce((r,e)-> r + e)

     - ikinci versiyonunda ise bir ilk değer verme söz konusudur. Ve boş bir stream gelirse verilen ilk değer neyse onu
       döner.
        Stram.of(cities).reduce("",(r,e) -> r + e + '-')

- reduce metodu hangi stream için kullanılıyorsa geri dönüş türü  eğer reduce metodunun
    - 1. overload'ı kullanılıyor ise Optional<T>
    - 2. overload'ı kullanılıyor ise T'ye geri döner.

------------------------------------------------------------------------------------------------------------------------
                                            14.06.2020
------------------------------------------------------------------------------------------------------------------------

- Temel türden(int,double yada long) bir diziden  Stream<T(Integer,Double,Long)> açılımının elde edilmesi
    1- int [] a = {1,2,3,4,5};
       Stream<Integer> stream = Stream.of(a).mapToObj(i -> i);
       Stream<Integer> stream = Stream.of(a).boxed();
       Stream<Integer> stream = IntStream.range(0,a.length).mapToObj(i -> a[i]);
       Stream<Integer> stream = Arrays.stream(a).mapToObj(i -> a[i]);
       Stream<String> stream = Arrays.stream(a).mapToObj(i -> a[i] + "");

- Bir stream arayüzüne ilişkin türler kullanıldıktan sonra kapatılır.

- map fonksiyonları a-> b yada a türünü alıp bir işlem yapıp yeniden a türüne dönüştürür.
- mapToObj IntStream,LongStream,DoubleStream'den ->Stream<B>
- mapToInt, mapToLong, mapToDouble ->  A  türünden -> XxxStream'e geri döner.
- Iterable arayüzünden spliterator metodu ile bir Iterable referansından Stream referansı elde edilebilir.

-Temel Stream'lerin(IntStream, DoubleStream, LongStream) sadece map(mapToObj metodu değil.) metodu hangi türden Stream için kullanılırsa
 o stream'i geri döndürür.(IntStream->IntStream'e, DoubleStream->DoubleStream'e,LongStream->LongStream)


- Iterable interface'inin default forEach metodu vardır. Ancak Iterable interface'inin stream metodu yoktur.

- Iterable'dan Stream elde etmek için spliterator metodu ve StreamSupport sınıfının static stream metodu kullanılır.

      Iterable<Integer> numbers = Sample.getNumber(10,20); // Iterable'i implemente etmiş bir nesne döner.
      Stream<Integer> stream  = StreamSupport.stream(numbers.spliterator(),false);//false'un sebebi paralelStream
      oluşmasını engeller.

- StreamSupport.stream metodunun(static) ilk parametresi Spliterator interface'i, ikinci parametresi ise stream'in parallel bir stream
  olup olmadığı ile alakalı olarak boolean bir değer alır. true ise parallelstream döner.

- Iterable'ın spliterator bu Spliterator interface'ini implemente etmiş bir sınıf döndürür.
- ikinci parametreye false geçilirse normal stream true geçilirse parallelstream verir(parallel stream birden çok thread
  ile çalışır.).

- StreamSupport çok ihtiyaç duyduğumuz bir yapıdır.

- Paralel programlama(Paralel computing)
    - Aynı bilgisayar üzerinde, farklı çekirdeklere işleri bölmek.(burada işi parçalarlar.)
    - Yada aynı bilgisayar üzerinde bir işi çekirdek sayısı kadar yapmak(işleri aynı anda yaparlar).(burada işi katlama
      vardır.)

- parallelstream kullanılırken dikkat edilmesi gereken bir mekanizmadır(Attığınız taş ürküttüğünüz kuşa değecek).


- Stream'lerin limit metodu(içte yapılacak döngüyü on kez çalıştırır.)
    - IntStream.generate(() -> r.nextInt(100)).limit(10).forEach(System.out::println); // on kez 0 ile 100 arasında sayı
      üretir.
    - IntStream.generate(()->r.nextInt(100)).filter(val -> val % 2 == 0).limit(10).forEach(System.out::println); //
       0 ile 100 arasında 10 tane çift sayı üretir.
- Not : eğer bir generate metodu var ise takip eden mutlaka bir limit metodu olmalıdır.

- Stream'in skip metodu
    - aldığı parametre kadar elemanı atlar.
        IntStream.of(grades).sorted().skip(grades.length - 3).forEach(System.out::println);
        Yukarıdaki kodda grades.length - 3 sorted edilmiş stream'in son 3 elemanını verir.

- sorted metodu aldığı Stream nesnesini sıralar. Generic stream'lar için büyükten küçüğe sıralama mevcuttur. Ancak
  primitive stream türleri için bu durum geçerli değildir.

- Not : Generic Stream'in sorted metodu default olarak Comparable olan bir nesne ister.

- collect metodu
    - parametre olarak Collectors interface'i türünden bir nesne ister.
    - collect metoduna Collectors.toList() metodunun geri dönüş değeri geçilirse Stream<T>'i bir List<T>'ye dönüştürür.

- IntStream, DoubleStream ve LongStream'i özgü boxed metodu sırasıyla Stream<Integer>,Stream<Double>,Stream<Long>'a
  dönüştürür(mapToObj yerine daha kısa bir kullanım sağlar.).
   var List<Integer> = IntStream
                          .range(0,100)
                          .filter(NumberUtil::isPrime)
                          .boxed() // mapToObj(val -> val)
                          .collect(Collectors.toList());

- collect metodu
    - <R,A> R collect(Collector<? super T, A, R> collector);
    - T girişin türü(Stream ne ile açılıyorsa o tür), A tamamen içsel implementasyon alakalı(genel olarak ? karakter olur)
      , R geri dönüş değeri
    - Collectors.toList'in geri dönüş değeri Collector<T,?,List<T>>'dir. Genelde ArrayList döner(Standart değildir.).
    - bundan kaynakları olarak collect metoduna Collectors.toList()  metodunu parametre olarak geçersek bize List<T>'ye
      geri döner.

    - Collectors.toSet() generic bir Stream'den bir Set<T>  elde etmemizi sağlar. Genelde HashSet döner(Standart
      değildir.).


- allMatch, noneMatch, anyMatch arasındaki ilişki.
    public static boolean isPrime(int val) {
        if (val <= 1)
            return false;

          return IntStream.rangeClosed(2, val / 2).allMatch(i -> val % i != 0);
        //return IntStream.rangeClosed(2, val / 2).noneMatch(i -> val % i == 0);
        //return !IntStream.rangeClosed(2, val / 2).anyMatch(i -> val % i == 0);
    }

    - allMatch predicate'ına geçilen ifadenin tam tersi noneMatch ile kullanılırsa aynı sonucu verir.

- distinct metodu tekrarlı eleman kalmasını engeller.
    - distinct metodu hem hashCode'a hem de equals'a bakar.
    - distinct metodunda ilk önce hangi veri elde edilirse o veri saklanır. Sonradan gelen aynı veri geçilmez.

- skip ve limit'in beraber kullanımı.
    - skip ve limit metodlarını beraber kullanarak bir stream'daki aradaki ürünleri alabiliriz.

- aralık veren bir metod olmadığı için önce limit sonra skip metodu kullanılarak bir aralık elde edilir.

------------------------------------------------------------------------------------------------------------------------
                                            20.06.2020
------------------------------------------------------------------------------------------------------------------------


- iterate metodu hem generic stream'ler için hemde primitive stream'lar için kullanılabilir.
- iterate metodu : T türünden bir(XXXStream'ler için bu tür ilgili primitive türdür.) tohum değeri alır. Bu tohum
   değerinden başlayaarak verilen UnaryOperator ile bir değer üretir.

- iterate metodu ile bir döngü oluşturulabilir. Döngü değişkenini şeklinde de kullanılabilir(Yani step miktarı verilir).
- iterate'in teker teker artırılan versiyonunun IntStream'in range'i  ile hiç bir farkı yoktur.

- iterate metodunun iki parametrelisini bir limit takip etmez ise sonsuza kadar sürer.

- concat metodu : birbirinden bağımsız iki adet veri yapısını aynı türden stream ile birliştirmemizi sağlar.
  concat metodunun  iki parametresi vardır. paramatreleri Stream<? extends T> a , Stream<? extends T> b
  concat metoduna geçilen parametreler birbirinden türetilmiş ise de kullanılabilir. Örneğin Concat metoduna geçilen
  veri yapısının birisi Number türünden bir stream diğeri de Integer türünden bir stream olabilir. Bu durumda açılım
  Number türünden kabul edilir.

- collect metodunun parametresi olan Collector interface'i ve Collectors sınıfı
    - Collectors sınıfı bir çok yararlı static metoda sahip geri dönüş değer Collector referansı olan bir sınıftır.
    - Collectors metodunun en çok karşımıza çıkacağı yer collect metoduna parametre geçerken'dir.

-----Collectors'in static yararlı metodları ----
- collect metodu ve Collectors sınıfı ancak ve ancak generic Stream'ler ile kullanılabilir. XXXStream ile kullanılamaz.

- toList metodu ilgili Stream'in T açılımında bir List<T> açılımını elde etmemizi sağlar.

- counting metodu ilgili Stream içerisinde kaç adet eleman olduğunu döndürür. Stream'in count'i ile aynı işlemi yapar.

- summingXXX metodu :  Geri dönüş değeri Collectors<T,?,R>'dır. summingInt metodu parametre olaral toXXXFunction
  alır. Bu metod'da kendisine gelen T parametresine göre bir int,double veya long değer ütretir.

- summingXXX metodu mapToXXX ve sum metodunun yaptığı iş kutulanırsa ikiside aynı işi yapar.
    Stream.of(cities).collect(summingInt(String::length)); //Integer üretir.
    Strema.of(cities).mapToInt(String::length).sum(); // int üretir.

- averagingXXX metodu : geri dönüş değeri olarak her zaman Collector<T,?,Double> üretir. metod hangi primitive türe
  göre kullanılırsa(averagingDouble,averagingInt,averagingLong) -> metodun parametresi o türden bir toXXXFunction lambda
  sı ister.

- partitioningBy metodu generic Stream'ler için geçerlidir. Partition anlam olarak iki grup demektir. Bir Predicate alır.
- Aldığı predicate'a uyanları map'in true key'ine karşılık gelir. uymayanlar map'in false kısmına gelir. Eğer herhangi
  bir key'de hiç değer olmasa bile ilgili key value çifti boş şekilde oluşturulur. Yani null döndürmez.
- Geri dönüş değeri Collector<T,?, Map<Boolean,List<T>>> açılımını geri döner. yani collect'e  parametre olarak
   partitioningBy metodunun geri dönüş değerini verirsek collect bize Map<Boolean,List<T>> açılımını döndüdür.

- Not : Para ile çalışmıyorsak %90 BigDecimal sınıflarının bizim için kullanımının bir önemi olmayacaktır. BigDecimal
  yerine double kullanılabilir.

- groupingBy metodu : gruplama ile partition'ın farkı gruplamada grup sayısı belirsizdir. Geri dönüş değeri Map'tir.
  Ancak gruplama parametresini Integer olarak kullanırsak 4 milyar tane grup olacaktır. Gruplamanın gerektiği bir çok
  durum için enum türleri kullanılır. partitioningBy'ın groupingBy'dan farkı partition verilen predicate'a göre Stream'i
  true ve false olacak şekilde sadece iki parçaya böler. Gruplama da ise bu sayının kaç olacağının bir önemi yoktur.

- groupingBy parametreye olarak gruplamayı neye göre geçeceğimiz belirtilir. Bu parametreye geçilen tür ne ise Map'in
  ilk parametresi de o olur. Bu parametreye sınıfı ilgilendiren bir parametre geçilmesi genel olarak önerilir. Ayrıca
  gruplama için genel olarak enum'lar kullanılır. Çünkü enum'lar için grup sayısı ve kontrol etme yapısı daha kolaydır.
- groupingBy ile elde edilen bir map'te mutlaka anahtar değerler var mı yokmu control edilmelidir. Aksi Taktirde kontrol
  edilmeden kullanılması RunTimeException oluşturur.
  Örneğin
    main()
    {
        Map<MaritalStatus, List<Person>> map = people.stream().collect(Collectors.groupingBy(Person::getMaritalStatus));
    }

    enum MaritalStatus {
        SINGLE, MARRIED, DIVORCED, UNDEFINED;
    }

  Map<G,List<T>> map = Stream.of(T).collect(Collectors.groupingBy(G))

- Not : groupingBy metodu gruplamayaı equals ve hashCode'a göre yapar. enum'ların hashCode'ları ordinal'leridir.

- groupingBy ile partitioningBy'in farkları
    - partitioningBy verilen predicate'a göre bir stream'i iki anahtarlı bir Map<Boolean,List<T>> açılımını döndürür.
    - partitioningBy geri dönüş değerinde anahtarlar'dan biri boş olursa boş bir map nesnesi yaratır.
    - groupingBy verilen Function'a göre bir stream'i Map<G,List<T>> açılımını döndürür.
    - partitioningBy geri dönüş değerinde anahtarlar'dan biri boş olursa ilgili anahtar için bir nesne yaratmaz.

- joining metodları :
    - String Stream'leri delimeter ile yada delimetersiz birleştirmeyi sağlar. Delimeter'a CharSequence implemente eden
      herhangi bir sınıf geçilebilir(StringBuilder).Geri dönüş değeri String'dir. Java 8 ile  beraber String sınıfına
      da static bir join metodu eklenmiştir. İki parametrelidir. 1. parametresi delimeter ister. İkinci parametresi ise
      CharSequnce ...  veya Iterable<? extends CharSequance> 'dır..
    - Stream.of(names).collect(Collectors.joining()); // names Stream'indeki String'leri doğrudan birleştirir.
    - Stream.of(names).collect(Collectors.joining(CharSequence delimeter)); //delimeter ile birleştirir.
    - String.join(CharSequence delimeter, CharSequence ... elements); // bir dizi alır.
    - String.join(CharSequence delimeter, Iterable<? extends CharSequence> elements) // bir Collection alır.

- joining metodununun özellikle ihtiyacı olduğumuz kısım elimizdeki Stream<String>'i herhangi bir şekilde bir List'e
  veya String []'a dönüştürmeden doğrudan Stream'e ait collect metodu ile kullanmamızı sağlar.

- maxBy ve minBy metodları
    - aldıkları comparator'e açıldığı T türünün min veya max elemanını döndüdür. Boş bir Stream olabileceğinden Optional
      döndürür.
    - minBy ve maxBy metodu Stream'in kendi min ve max metodları ile yaptığı işin aynısını yapar.
    - minBy ve maxBy metodu veya Stream'in kendi min ve max metodu olsun mutlaka bir Comparator ister. parametresiz
      overload'ları implemente edilmemiştir.

- Not : max ve min metodları XXXStream'ler için Comparator'süz çalışır.

- reducing metodu(Collectors'a ait)
    -  reduce ile aynı işlemi yapar. tamamen parametrik yapısı da ve geri dönüş değerleride aynıdır.

- Yukarıdaki collect'e parametre olarak geçilen metodların hepsi Generic Stream ile kullanılabilecek metodlardır.
  Temel Stream ile collect'in Collector parametreleri kullanılamayacağı için yukarıdaki fonksiyonlar kullanılamaz.


- Stream'lerin toArray metodu 2 adet overload'ı vardır.
    -  Object [] dönen dikkat bu fonksiyon Object [] türden bir nesne döner. Bu referansın dinamik türü de Object []'dir.
       cast işlemleri haksız dönüşüm sağlar.
    -  ikincisi T []'a dönen, kendisine verilen IntFunction(bir int değer alıp T döner) lambdasına göre int değer alıp T
       türünden dizi üretir. methoda lambda ifadesine yerine T[]::new method reference'ı geçilebilir.
------------------------------------------------------------------------------------------------------------------------
                                            21.06.2020
------------------------------------------------------------------------------------------------------------------------

- partitionAlgoritması çözüldü.

------------------------------------------------------------------------------------------------------------------------
                                            SPRING BOOT
------------------------------------------------------------------------------------------------------------------------

- Bundan önce yapılan her şey bir oracle ürünüydü(Java SE idi).
- Spring Java'ya ait değildir. Java alt yapısını kullanılır.

- Spring çok genel bir framework'tur. WEb için Spring MVC(Spring web), Spring data database için, Spring core hemen
  hemen her uygulamanın yapılabildiği bölümdür.

- Spring java groovy ve kotlin ile kullanılabilen bir framework'tur.

- Java'nın web servlet denilen bir yapıda kullanılır.

- Spring çıktıktan sonra muadili olan(JSF,JSP) her şeyin yerine kullanılmaya başladı.

- Spring ilk çıktığı zamanlar(Classic Spring denirdi.) iyiydi ancak konfigürasyonu zordu. Sonrasında Oliver ve arkadaşları
  Spring Boot'u çıkardılar.

- Spring boot spring içerisinde ayrı bir teknolojidir. Spring içerisinde ayrı bir teknolojidir.

- Spring boot'un en önemli artısı auto-configuration'dır(Sadece annotation ile yapılır).
- Framework'lerin asıl amacı hammaliye işlerini elimizden alır.

- Spring boot'un en büyük  artılarından biri olan ide olsun yada olmasın Spring initializr ile bir spring projesi
  oluşuturabiliriz.
- Bir basit Spring boot projesi direk spring initializr sitesinden indirilir.

- Spring ile kullanmayı öğreneceğimiz ayrıca bambaşka bir teknoloji daha olacak.

- Built araçları nelerdir ve javada ki built araçları
    - Tüm projeye ilişkin detayların(kullanılan library'ler, version numarıları, artifact'ler) hepsini belli komutlar
      yazarak bir arada yapabilmemizi sağlayan teknolojilere built araçları denir.

    - Java için şu anlık iki adet araç vardır. Bunlar Maven ve Gradle ile yapılır. İkisinin de temel hedefi aynıdır.
       Bunların temel script'leri vardır.
        Maven -> Genel de java uygulamaları için kullanılır. XML formatını kullanır
        Gradle -> Genelde android uygulamaları için kullanılır. JSon formatını kullanılır.


- Spring initializer'da ki field'lar anında değişebilirler
    - group_name -> projenin paket adı gibidir. jar'ların çıktısının başına koyulur.
    - artifact -> artiface ve name aynı olabilirler
    - name -> artiface ve name aynı olabilirler. Projenin genel ismi verilebilir.
    - description
    - package name -> org.csystem...

------------------------------------------------------------------------------------------------------------------------
                                            27.06.2020
------------------------------------------------------------------------------------------------------------------------

- bir import direktifinde sadece springframework ismi geçiyor ise bu paket springframework'une aittir.
- eğer bir springframework paketinin boot isminde bir alt paketi var ise bu springboot'a ait bir pakettir.

- Spring teknolojisi web uygulamalarında da kullanılan bir teknolojidir.
- Spring boot teknolojisi Spring framework'unu kolaylaştırmak için tasarlanan Spring içerisinde kullanılan bir teknolojidir.
- Spring boot ile klasik Spring ile yapılan bütün işlemler yapılabilir.

- Builder araçlarına örnek olarak maven ve gradle verilebilir. Bunlar birbiri yerlerine kullanılabilen araçlardır.
    - maven
    - gradle

- Bu araçların hedefleri aynı sadece kullanım şekilleri farklıdır. maven xml, gradle json formatını kullanılır.

- XML(Extensible markup language) nedir ?
- Bir bilgisayar dilidir. programlama diili değildir. Akış içermiyordur.

- Markup dilleri isimlerini element denilen yapılardan meydana gelir.
<tag> -> açılış tagı.
- xml'in kendine ait bir tag mekanizması yoktur.

- xml de hedef herkesin kendi tag mekanizmasını kullanmasıdır.

<devices> -> açılış tagı

</devices> -> kapanış tagı
açılış ve kapanış tagının bütününe element denir.

- bir xml tagı içerisinde yazı="deger" çiftine attribute denir.
<devices id="1" name="test" > devices'in id attribute'i, bazen sadece attribute'in var olduğunu belirtmek için
 değer yazılmadan da kullanılabilir.

 <devices id="1" name="test" active>
 </devices>

- bir projenin içerisinde pom.xml dosyası bir maven dosyasıdır(gradle dosyaları .gradle uzantılıdır.).

- Spring boot java 8'den önce kullanılan bir teknoloji değildir.

- Spring boot projesinde pom.xml dosyasında parent elementinin içindeki bilgiler değiştirilmez.
- Burada değiştirebilecek tek şey spring boot'un yeni versiyonu çıktığında ilgili version numarası değiştirilebilir.

- groupid kısmı altında kalan 4-5 satırlık kısım proje ile ilgili metadata'ların bilgilerini içirir.

- Spring boot'un annotation'ları
    - SpringBootApplication (Aşağıdaki üç annotation bu annotation yazarken belirtilmiş. .class dosyasından gözükeblir. )
        - SpringBootApplication annotation'ı ComponentScan annotation'ı ile beraber bildirilmiştir. Bu annotation
          bildirilirken default olarak aramaların sadece ilgili paket ve sub paketletde yapılacağı şekilde bildirilmiştir.
          Bu değiştirilebilir. Default'unda sadece o sınıfın bulunduğu paket ve o paketin alt paketlerinde aranacak
          şekildedir.
    - SpringBootConfiguration -> Spring frameworkun spring boot ile alakalı konfigürasyon'ların yapılabileceğini
      uygulamada gösterir.

    - EnableAutoConfiguration -> Spring boot'da kodu yazan kişinin otomatik konfigürasyonu var ise onuda kontrol et
      anlamında kullanılır

     - ComponentScan -> Proje içerisinde nerelerde arama yapılacağını belirttiğimiz yerdir.

- SpringBootAnnotation'ı genellikle main'in bulunduğu sınıfa yazılır. Genel olarak bu annotation buradan silinmez.
  Sadece yanına bazı annotation'lar eklenir.

- Springboot'un reflection kısmı uygulamanın meta data bilgilerine SpringBootApplication annotation'ı ile bakar. Bu
  annotation Spring boot'ta genellikle değiştirmeyeceğimiz ilk annotation'dır.

- Spring boot projesini çalıştıran metod SpringApplication sınıfının run metodudur.

- Spring boot'u Spring boot yapan deployment'ının basitleştirilmesidir.

- Maven aracının package isimli switch'i yardımı ile hiç bir şey yazılmadan çalışılabilir bir jar haline getirilebilir.

- SpringBean kavramı : Bir sınıfın çeşitli konfigürasyonlar ile(dependency injection gibi) springe uygun hale gelmesi
  durumunda bu sınıfa SpringBean denir.

- SpringBean ile SpringBoot'taki bir sınıfı Bean yapmak başka şeylerdir.

- Component annotation'ı bir sınıfı SpringBean yapmamızı sağlayan annotation'dır. Component işaretlenmiş bir sınıf
  eğer scope'ı singleton ise spring tarafından bir kez yaratılır. Bu durum sadece spring için geçerlidir. Java'nın
  sentaks kuralları gereği(örneğin bu sınıftan bir sınıf türetilmiş ise) o sınıftan başka bir nesne yaratılır.

- Bir sınıfı Component olarak işaretlendiğinde bu sınıflar bean durumuna gelirler.
    @Component // buradan sonra bu sınıf bean anlamına gelir. Bu tarz şeylere sterotype'da denir.
    class Employee {

    } //Eğer bu sınıf SpringBootApplication'ın bulunduğu paket içerisinde değilde başka bir pakette bulunur ise  veya
    component işaretlenmez ise o türden bir nesne yaratılamaz.()

- Sınıfın ctor'unun private olması durumunda bir çok framework erişimi engeller(Spring boot'ta çlışır.).

- Bir bean'in scope denilen bir kavramı vardır. Bir bean'in default scope'u default olarak singleton'dır(O türden sadece
  bir nesne yaratılacaktır.).Spring boot singleton bir bean için daha ayağa kalkarken ilgili nesne yaratılır.
  Eğer bu scope kavramı prototype olarak işaretlenir ise  nesne ne zaman yaratılacak ise o zaman yaratılır.

  @Component
  @Scope("prototype") // Employee türünden bir nesne ne zaman yaratılmak istenirse o zaman yaratılır.
  public class Employee {
      public Employee()
      {
          System.out.println("Employee.employee");
      }
  }

- Scope annotation'ın value isimli bir elemanı vardır. Bu yüzden annotation'da value="prototype" şeklinde kullanıma
  gerek yoktur.

  @Component// Device türünden nesne spring boot çalışmaya başladığı anda yaratılır. Bir Bean'in default scope'u singleton'dır.
  public class Device {
      public Device()
      {
          System.out.println("Device.Device");
      }
  }

- Bir bean'in scope'u prototype işaretlenmez ise default scope'u singleton'dır.
- Component işaretlenmiş bir sınıfa bean denir.

- Singleton scope ile isimlendirilmiş sınıfların yaratılması paket derinlikleri ve isimlerinin sırasına göre yaratılır.
  Örneğin daha derin pakkette olan bir sınıf  daha sonra yaratılır. Aynı paketteki farklı isme sahip iki sınıf'tan hangi
  sınıfın ismi daha önce geliyor ise o sınıf daha önce yaratılır.

- PostConstruct annotation'ı
    - Bir bean yaratıldıktan hemen sonra o bean'e ilişkin bir metodun çağrılması istendiğinde kullanılan annotation'dır.
      Eğer ki bu nesnelerin scope'u singleton ise uygulama ayağa kalkamadan ilgili metod çağrılır. Scope prototype
      ise nesne yaratıldıktan sonra method çağrılır.

    @Component
    public class DateDisplay {
        public DateDisplay()
        {
            System.out.println("DateDisplay.DateDisplay");
        }
        @PostConstruct // eğer bu annotation kaldırılır ise nesne sadece yaratılır. Bu metod çağrılmaz.
        public void displayDate()
        {
            LocalDate now = LocalDate.now();
            System.out.printf("%02d/%s/%02d",now.getDayOfMonth(), now.getMonth(), now.getYear());
        }
    }


--- Dependency Injection ----

- SOLID prensiplerinden sonuncusudur.
    - Dependency inversion(Yeni nesil adı Dependency Injection)

- Dependency injection'da bir sınıfın nasıl yaratıldığının yada sınıfın yaratılırken ne olduğunun detaylarının
  bizim sınıfımız açısından bir önemi yoktur . Örneğin bir LocalDate sınıfı için LocalDate ile yapılan işlemin
  ne olduğunun bir öneminin olması sadece biz ne tür bir LocalDate nesnesi istersek bize onu veren bir sınıfın olmasıdır.

- Detayları ile bizim ilgilenmediğimiz, bizim kodumuzu detaylardan bağımsız yazdığımız durumlardır.
  Biziö için önemli olan şey kullanılacak o sınıfın referansını tutacağımız bir değişkendir.

- Dependency Injection tam olarak bir sınıfın işini yapabilmesi için bağımlı olduğu detayları sınıf içinde halletmek değil
  dışarıdan halledilmiş bir şekilde almaktır.

- Dependency Injection'ı implemente etmenin SpringBoot'ta üç yolu vardır.
    1-) Field Injection -> FieldInjection önerilmez.
    2-) Constructor Injection -> En çok kullanılan injection yöntemi budur. Diğer ikisi daha az kullanılacaktır.
    3-) Setter Injection

- Bir injection işlemi yapabilmek için özel bir annotation kullanılır. İsmi AutoWrited'dır.
- auto wired anlam olarak otomatik bağlanmış şeklinde çevirilebilir.

- Spring 4 ile beraber bir sınıfın bir adet  constructor'ı var ise autowired işaretlenmesine gerek olmadan injection
   default yapılır.

- Eğerki injection yapılacak sınıf kendi sınıfımız ise sadece @Component olarak işaretlenmesi yeterlidir.
- Başka kütüphaneden alınan bir sınıf ise farklı yöntemler uygulanır.
- injecte edilecek sınıf'ın scope'unun nesnesinin singleton mu prototype mı olacağı senaryoya bağlıdır.

- ConstructorInjection için enjekte edilecek nesnenin önceden yaratılması gerekirken setter ve field injection
  için eğer ilgili nesnenin scope'u prototype ise bu nesneler yaratıldıktan sonra enjekte edelecek nesne yaratılır.

- Constructor injectionda enjekte edilecek sınıfın scope'u prototype ise bu construcor çağrılmadan ilgili sınıf nesnesi
  yaratılır.

- Diğerlerinde ctor çağrıldıktan sonra enjekte edilecek sınıf injection edilir.


    @Component
    @Scope("prototype")
    public class DateTime {
        private final LocalDate m_localDate = LocalDate.now();

        public DateTime()
        {
            System.out.println("DateTime");
        }
        public int getYear()
        {
            return m_localDate.getYear();
        }

        public int getMonthValue()
        {
            return m_localDate.getMonthValue();
        }

        public int getDayOfMonth()
        {
            return m_localDate.getDayOfMonth();
        }
    }

- Yukarıdaki DateTime sınıfı aşağıdaki örnekler için yazılmıştır.

1-) FieldInjection

    - Spring boot burada DateTimeFieldInjectionDisplay sınıfında reflection bakıp Autowired isimlendirilmiş bir elemanı
      var ise o sınıf türünden bir component yaratılmış ise(yani DateTime'ın scope'u singleton ise) doğrudan atama yapar.
      Eğer DateTime'ın scope'u prototype  DateTime nesnesi yaratıldıktan sonra ilgili sınıfa atanır.
    @Component
    public class DateTimeFieldInjectionDisplay {

        @Autowired // field injection yapıldı. Field injection için spring boot'ta bir ctor yazılmaz derleyici sınıfın
        ctor'u çağrıldıktan sonra injection işlemi yapılrı.
        private DateTime m_localDate;

        public DateTimeFieldInjectionDisplay()
        {
            System.out.println("DateTimeFieldInjectionDisplay");
        }

        @PostConstruct
        public void display()
        {
            System.out.printf("%02d/%02d/%04d%n",m_localDate.getDayOfMonth(),m_localDate.getMonthValue(),m_localDate.getYear());
        }

    }
2-) ConstructorInjection

- Constructor injection'da aşağıdaki örnek için  DateTimeConstructorInjectionDisplay nesnesi
  yaratılmadan önce DateTime türünden nesnenin yaratılmış olması gerekir.
- Spring 4.3'ten ctor injection'da eğer sadece bir adet ctor var ise  Autowired annotation'ının yazılmasına gerek yoktur.
  Ancak birden fazla var ise autowired'ın hangi ctor için uygulanılacak ise o ctor Autowired belirtilmelidir.
    @Component
    public class DateTimeConstructorInjectionDisplay {
        private DateTime m_dateTime;

        //@Autowired//Burada autoWired'ın bir önemi yoktur. Gizli bir autowired varmış gibi kullanılır.
        public DateTimeConstructorInjectionDisplay(DateTime dateTime){
            System.out.println("DateTimeConstructorInjectionDisplay");
            m_dateTime = dateTime;
        }

        @PostConstruct
        public void display()
        {
            System.out.printf("%02d/%02d/%04d%n",m_dateTime.getDayOfMonth(),m_dateTime.getMonthValue(),m_dateTime.getYear());
        }

    }


3-) SetterInjection
    @Component
    public class DateTimeSetterInjectionDisplay {
        private DateTime m_dateTime;
        public DateTimeSetterInjectionDisplay()
        {
            System.out.println("DateTimeSetterInjectionDisplay");
        }

        @Autowired
        public void setDateTime(DateTime dateTime)
        {
            this.m_dateTime = dateTime;
        }Sonuçta bir inject ten
sonra run metodunu cagırıyor
O yüzden galıba

        @PostConstruct
        public void display()
        {
            System.out.printf("%02d/%02d/%04d%n", m_dateTime.getDayOfMonth(), m_dateTime.getMonthValue(), m_dateTime.getYear());
        }

    }

- Field ve setter injection'lar da nesne referansı final bildirilemez.
- Dependency injection aggregation gibi düşünülebilir. Ancak aggregation'ın ilerlemiş halidir.

- Component ve scope annotation'ları SpringFramework'üne özgü annotationlardır.

- Şu ana kadar yazdığımız bütün injection işlemleri kendi yazdığımız sınıflar üzerinden yapabiliyorduk.

- Burada bizim yazmadığımız veya Spring'e ait olmayan bir sınıf kullanılırsa (örneğin standart LocalDate sınıfı) Spring
  boot bize o  sınıf türünden bir nesnenin yaratılmasını doğrudan sağlıyamaz. LocalDate'i Component olarak bildiremeyiz.
  Bir sınıfın kaynak kodu olmadan o sınıfı Component bildiremeyiz. Ancak o sınıfı bir Spring bean haline getirebiliriz.

- Yukarıdaki sorun için iki farklı çözüm vardır. Birincisi LocalDate sınıfını sarmalayan bir sınıf yazıp ilgili sınıfı
  component bildirmek. Bu durum gene LocalDate sınıfına bir bağımlılık gerektirir.

- Asıl çözüm Spring boot'un yaklaşımıdır. Configuration ve Bean annotation'ları ile çözülür.
------------------------------------------------------------------------------------------------------------------------
                                            @Configuration and @Bean annotation'ı
------------------------------------------------------------------------------------------------------------------------
- Spring ekibi yukarıdaki sorunun çözümü için Configuration annotation'ını yazdı. Bu annotation'ın eklendiği sınıflar hem
  component özelliğini gösterir. Hemde kendi içerisinde çalışıyor olan bir takım metodları istenildiğinde otomatik
  çağrılmasını sağlar. Bu metodlar sayesinde de bir Bean üretimini sağlar.

- Configuration annotation'ı ile işaretlenmiş bir sınıf içerisinde kullanılabilen sadece metodlara işaretlenibilen özel
  bir annotation vardır. İsmi Bean'dir(Target'ı method'dur.).

- Aşağıdaki yapı sayesinde standart kütüphaneye ait yada dışarıdan alınmış bir java dosyasının herhangi bir sınıfı
  kullanılabilir. Aşağıda ki yapıda yapılan, eğer uygulamanın herhangi bir yerinde LocalDate nesnesi istenir ise bu
  metod kullanılarak LocalDate nesnesi üretilir. Böyle işaretlenmiş metodlar geri dönüş değerlerini bean olarak vermeye
  yarar.
  @Configuration
  public class DateTimeConfig {
      @Bean
      public LocalDate getLocalDate()
      {
          return LocalDate.now();
      }
  }

- Bu metodu çağırılabilmesi içinde mutlaka bir bir yerde bir(field,setter veya ctor -> ctor için default yapılır)
  autowired bildirilmelidir. Bu metodun çağrılmaması ve çağrılmayacağı durumu error değildir. Ancak yazılmasının hiç
  bir manası yoktur.

- Bean işaretlenmiş bir metod Ya configuration ile işaretlenmiş bir sınıf içerisinde yada SpringBootApplication ile
  işaretlenmiş bir sınıf içerisinde bulunmalıdır(SpringBootApplication ile işaretlenmiş bir sınıf içerisinde
  işaretlenmesine çok nadir rastlanır.).

- Springframework bir sınıftan bir SpringBean elde etmesi için o sınıfın @Component olarak işaretlenmesi gerekir.
- Springframework bir metoddan bir SpringBean elde etmesi için o sınıfın @Configuration ile o metodunda @Bean ile
  bildirilmesi gerekir.

- Cofiguration işaretlenmiş bir sınıfın Scope'u singleton'dır. değiştirilemez. Bu sınıfın @Bean işaretlenmiş metodu
  bir Spring bean üretir.


- Bean işaretlenmiş bir metoda da ayrıca bir scope verilebilir. Eğer scope verilmez ise metod bir kez çağrılır. Geri
  dönüş değeri tutulur. Eğer prototype olur ise metod her bir injection işlemi için çağrılır.


- DependencyInjection with Configuration
    @Configuration
      public class DateTimeConfig {
          @Bean
          public LocalDate getLocalDate()
          {
              return LocalDate.now();
          }
      }


    @Component
    public class DateTimeDisplaySetterInjection {
        private LocalDate m_dateTime;
        public DateTimeDisplaySetterInjection()
        {
            System.out.println("DateTimeSetterInjectionDisplay");
        }

        @Autowired
        public void setDateTime(LocalDate dateTime)
        {
            this.m_dateTime = dateTime;
        }

        @PostConstruct
        public void display()
        {
            System.out.printf("%02d/%02d/%04d%n", m_dateTime.getDayOfMonth(), m_dateTime.getMonthValue(), m_dateTime.getYear());
        }

    }

- SpringBean  nesne yaratılmıi nesnelere denir.
- NOT : Bir Bean yaratılırken herhangi bir scope verilmez ise her zaman scope'u her zaman singleton'dır. Spring'de şu
  ana kadar gördüğümüz iki adet bean üreten annotattion,
    1- Component
    2- method annotated with Bean

- Eğerki Autowired'a karşılık gelen bir Bean üretecek Componen işaretlenmiş  sınıf veya Bean işaretlenmiş bir metod yok
  ise error oluşur.
- Singleton kullanmanın belleksel bir durum söz konusu değil, boşu boşuna bir nesne yaratma maaliyetinin olmaması
  demektir.
------------------------------------------------------------------------------------------------------------------------
                                            28.06.2020
------------------------------------------------------------------------------------------------------------------------

- Component dependency injection'da kullanabileceğimmiz sınıfları temsil eder.
- Bir sınıfı component yapmak o sınıfı bean'e çevirmektir.

- Spring'de bean'lere isim verilebilir
- Component olan bir bean'in default ismi, işaretlenen sınıfın isminin küçük harflerinden oluşan halidir.

- konfigürasyon dosyasından alınan bean'lere de isim verilebilir.
- Bean işaretlenmiş bir metodda bean ismi metodun isminin küçük harflerinden oluşan halidir. Bir beanin ismi özellikle
  qualifier annotation'ı ile bir anlam kazanır.@

- Bir configuration'dan bean elde etmek ile bir component'ten bean elde etmek arasında hiç bir fark yoktur. ikisinde de
  bean elde edilir. Fark yalnız nesneyi initialize ederken yapılan detaylar configuration'da metod içerisinde halledilir.

- Dependency inversion prensible, dependency injection ve ioc(inversion of controls) bu üç terim birbirine çok yakın
  terimlerdir. Bunların çıkış noktası solid'in d'si olan dependency inversion'dır.

------------------------------------------------------------------------------------------------------------------------
                                            Application Runner interface'i
------------------------------------------------------------------------------------------------------------------------


- Component veya Configuration(Configuration annotation'ı içerisinde ki bean metodlar) türünden bean'lerin scope'ları
  singleton ise daha spring boot ayağa kalkmadan bu nesneler hayata gelir.

- Eğer bunların scope'ı prototype ise nesne zaman istenirse ozaman yaratılır.

- Component ve configuration arasında ki fark
    - Component dependency injection da kullanacağımız sınıfları temsil eder.
    - Configuration ise bean metodlar yazmak da dahil olmak üzere bir takım konfigürasyonlara ilişkin sınıfları temsil
      eder.

    - Configuration'da ApplicationRunner'lar injection şeklinde kullanılacak bean'ler değillerdir.


- ApplicationRunner interface'ini döndüren bir metod yazılır ve bu metod @Bean işaretlenir ise(Bir metodun @Bean
  işaretlenebilmesi için bulunduğu sınıfın @Configuration işaretlenmesi gerekir.) buradaki metod Springboot tarafından
  çağırılır. Bu metodun çağırımı tamamen spring boot tarafından yapılır. Herhangi bir şekilde dependency injection
  yapılıpi post construct işlemine gerek kalmadan bu işlem gerçekleştirilir.

- Burada iki önemli farklılık vardır. Application interface'ini döndüren bir method uygulama ayağa kalktıktan sonra
  çağrılır. PostConstruct ve singleton'a sahip bir metodda durum böyle değildir.

- Aynı paketteki ApplicationRunner döndüren metodlar harf sırasına göre aynı sınıf içerisindeki application runner
  döndüren metodlar ise bildirildikleri sıraya göre hangisi önce ise o  spring boot onu çağırır. Metodlar senkron bir
  şekilde çağırılır.

- Application runner bir functional interface'dir. Bu yüzden ApplicationRunner referansına bir lambda ifadesi atanabilir.
  ApplicationArguments türünden bir parametre ister.

- Bean annotation'ı ile neden nesne yaratılır.
    - Sınıfın kaynak kodları bizim tarafından yazılmamıştır ve component değildir.
    - component işaretlensin yada işaretlenmesin bir sınıftan nesne elde edilmesini bir algoritmaya göre isteyebiliriz.


- SpringBoot ApplicationRunner döndüren ve bean olarak bildirilmiş bir metod görüyor ise geri dönen referansın run
  metdounu çalıştırır.

- ApplicationRunner spring boot tarafından çalıştırıldığı için spring boot mutlaka ApplicationRunner isteyecektir.
  Burada ApplicationRunner'ın scope'unun bir önemi yoktur. Çünkü spring boot çalıştıktan hemen sonra ApplicationRunner'
  lar çağırılacaktır.

- ApplicationRunner bean'leri hiç bir zaman programı çok meşgul edecek şekilde yapılmamalıdır.


- Bir Bean'e isim yada value vererek  bir order  oluşturulamaz  .

- Order annotation'ı aynı interface'i implemente eden  sınıflar için bir kullanılan bir annotaion'dır. Eğer nesneler her
  seferinde farklı bir sınıf'tan türetiliyor ise  order annotation'ının bir işlevi yoktur.

- Normalde bir Component'in yada Bean bir metod'dan yaratılma aynı pakette ise isim karşılaştırmasında hangisi daha önce
  ise o daha önce yaratılır.
  Aynı sınıfta ise hangisi daha önce bildirilmiş ise o daha önce yaratılır.

- Order annotation'ı ile aynı interface'den türemiş sınıflar'da hangisinin daha önce yaratılacağına bir sıra verilebilir.

- ApplicationRunner injekte edilecek bir bean türü değildir. Spring Boot tarafından çağırılır.

- ApplicationRunner ile yapılacak bir işlem Component işaretlenmiş PostConstruct bir metod  ile de yapılabilir.
  Ancak ApplicationRunner interface'i Spring boot'un inject olarak aldığı bir interface'dir.

- Aynı türe dönen birden fazla  @Bean metod var ise spring hata verir.

- Spring Boot'ta her şey dependency injection ile işlenir.

- ApplicationRunner dönen ve Bean işaretlenmiş metodlar SpringBoot ayağa kalkarken hepsi çağrılır.

- Bean metodlar üzerinden order yapılamaz.

- Spring boot'ta aynı interface'ler ve taban sınıfların bean'leri arasında sıra söz konusudur. Order o taban sınıftan
  veya interface'den türetilmiş bir sınıfa verilmelidir. Bir lambda'ya order verilemez.

- field injection hemen hemen hiç tercih etmemeliyiz.
- pratikte en çok kullanılan injection yöntemi ctor injection.
- Bir sınıfın birden çok ctor'u var ise hangi ctor'un injection ile çalışacağına karar vermek için autowired ile
  işaretleriz.

- Bir sınıfın ancak ve ancak bir tek constructor'ı autowired işaretlenebilir.

- Bir ctor'da aynı anda iki tane dependency alınabilir.
    @Autowired
    public DateTimeApplicationRunner(LocalDate date,LocalTime time)
    {
        m_date = date;
        m_time = time;
    }//iki adet bean ile injection yapılabilir.


------ Collection dependency injection ------------
- spring collection injection yapabilir.
- spring ortak bir noktaya sahip bean'leri bir araya getirerek bir dependency injection yapılmasını sağlayabilir.

- Örneğin aynı interface'i IOperation'ı implemente eden üç farklı sınıf @Component olarak işaretlenmiş olsun. Bu
  sınıfları inject edebileceğimiz, Collection veya List interface'li bir sınıf yazılabilir(List<IOperation>). Spring
  bizim için bu üç sınıftan component işaretlendiği için her birinden bir nesne yaratır ve bu sınıflara bir araya
  toplayıp ilgili sınıfa enjekte eder. Eğer hiç bir nesne yaratılmaz ise springframework boş bir list'e yada collection
  injekte eder. Bu durumda uygulama da hiç component oluşmamış ise uygulama patlamaz.

- Normalde dependency injecton'da T türünden bir referans için sadece tek bir bean metod yazılabilirdi. Ancak bu durum
  Collection<T> türüne spring tarafından yapılacak bir injection söz konusu olduğunda birden çok bean metod aynı değere
  dönebilir.

- Aşağıdaki kod normalde error oluştururdu. Ancak injection Yapılacak sınıfın referansı Collection<IOperation<Integer>>
  olduğundan kaynaklı kod geçerlidir.
  @Configuration
  public class ApplicationConfig {
      @Bean
      public IOperation<Integer> getOperation()
      {
          return new IntModulusOperation();
      }

      @Bean
      public IOperation<Integer> getOperation2()
      {
          return new IntAddOperation();
      }

      @Bean
      public IOperation<Integer> getOperation3()
      {
          return new IntMultiplyOperation();
      }
  }
------------------------------------------------------------------------------------------------------------------------
                                            05.07.2020
------------------------------------------------------------------------------------------------------------------------
- Bir Spring boot uygulanamasının çalışma sırası
    - SpringApplication.run(...); ile spring boot bir takım ilk işlemleri yapar(Bunlara spring initialization denir).
    - Bu işlemler gerekli nesnelerin yaratılması ve configuration işlemlerinin yapılmaısıdır.
    - Bundan sonra varsa ApplicationRunner'lar yapılır.
    ...
    ...
    ...
    ...

- Bir spring boot programı içerisinde aynı isimde iki bean olamaz. Farklı paketlerde ki iki farklı configuration
  içerisinde iki farklı bean metod aynı isimde olamaz.
  package x;
  @Configuration
  class  ApplicationRunnerConfig {

    @Bean
    public ApplicationRunner runApplication()
    {
    }
  }
  package y;
    @Configuration
    class  ApplicationRunnerConfig {

      @Bean
      public ApplicationRunner runApplication() // error.  aynı türden referansları dönen bean'lerin ismi default olarak
      {                                            aynı olamaz.
      }
    }

----- Qualifier annotation'ı -----

- Inject işleminde hangi bean'in kullanılacağını belirtilen annotation'dır.
- Bir bean'in ismi default olarak yazıldığı metodun yada sınıfın ismi'dir. Örneğin

- Bir bean'e isim iki şekilde verilebilir.

1-) Component veya  bean annotation'ı içinde
    @Component("intAdd")
    class IntAddOperation implements IOperation {
        //..
    }

    veya

    @Configuration()
    class OperationConfig implements IOperation {
        @Bean("intMultiply")
        public IOperation getOperation()
        {
            return new IntMultiplyOperation();
        }
    }

2-)Qualifier annotation'ı ile
    @Component
    @Qualifier("intAdd")
    class IntAddOperation implements IOperation {
        //..
    }

    veya

    @Configuration
    class OperationConfig implements IOperation {
        @Bean
        @Qualifier("intMultiply")
        public IOperation getOperation()
        {
            return new IntMultiplyOperation();
        }
    }

- Bir bean'e herhangi bir isim verilmez ise işaretlendiği sınıfın(sınıfta isimin ilk harfi küçüktür.) veya metodunismini alır.
   @Component // burada üretilen bean'in ismi intAddOperation'dır. Yani sınıfın ilk harfi küçüktür.
   class IntAddOperation implements IOperation {
       //..
   }
   @Configuration
   class OperationConfig implements IOperation {
       @Bean// bean'in ismi getOperation'dır.
       public IOperation getOperation()
       {
           return new IntMultiplyOperation();
       }
   }


- Aynı sınıfı implemente eden sınıflar arasındaki order ilişkisi yapılması durumu List interface'ini implemente eden
  sınıflar için geçerlidir. Çünkü öncelik sonralık ilişkisi bu sınıflar için vardır. Collection interface'ini implemente
  eden sınıflar için böyle bir durumun olacağı kesin olmayacağından yaratılma sırası buna göre olmaz.

- Qaulifier annotation'ı
    - bean bir sınıfa
        @Component
        @Qualifier("intAdd")
        class IntAddOperation implements IOperation {
            //..
        }

    - bean dönen bir metoda
        @Configuration
        class OperationConfig implements IOperation {
            @Bean
            @Qualifier("intMultiply")
            public IOperation getOperation()
            {
                return new IntMultiplyOperation();
            }
        }
    - field injection'da enjekte edilecek field elemanına
        public class ApplicationRunnerConfig {
            @Autowired
            @Qualifier("getOperation")
            private IOperation m_operation;
            //..
         }

    - ctor injection'da enjekte edilecek method parametresine
        public class ApplicationRunnerConfig {
            private final IOperation m_operation;

            public ApplicationRunnerConfig(@Qualifier("getOperation")IOperation operation)
            {
                m_operation = operation;
            }

            @Bean
            public ApplicationRunner runApplication()
            {
                return args-> {
                    System.out.println("ApplicationRunnerConfig");
                    System.out.println(m_operation.apply(15,25));
                };
            }
        }
    - setter injection'da enjekte edilecek method parametresine
        public class ApplicationRunnerConfig {
            private IOperation m_operation;

            @Autowired
            public void setOperation(@Qualifier("getOperation")IOperation operation)
            {
                m_operation = operation;
            }

            @Bean
            public ApplicationRunner runApplication()
            {
                return args-> {
                    System.out.println("ApplicationRunnerConfig");
                    System.out.println(m_operation.apply(15,25));
                };
            }
        }


    - setter injection'da @Autowired'ın hemen altında kullanılabilir.
        public class ApplicationRunnerConfig {
            private IOperation m_operation;

            @Autowired
            @Qualifier("getOperation")
            public void setOperation(IOperation operation)
            {
                m_operation = operation;
            }

            @Bean
            public ApplicationRunner runApplication()
            {
                return args-> {
                    System.out.println("ApplicationRunnerConfig");
                    System.out.println(m_operation.apply(15,25));
                };
            }
        }

- Constructor Qualifier olarak işaretlenemez.

- Normal şartlar altında aynı türden reference döndüren bean'lerin bir program içerisinde bulunamaz. Aşağıdaki örnek
  farklı dosyalarda yazılmıştır

    @Configuration
    public class OperationConfig2 {
        @Bean
        public IOperation getOperation2()
        {
            return new IntMultiplyOperation();
        }
        @Bean
        public IOperation getOperation()
        {
            return new IntMultiplyOperation();
        }
    }

    @Configuration
    public class OperationConfig {
        @Bean
        public IOperation getOperation2()
        {
            return new IntMultiplyOperation();
        }
        @Bean
        public IOperation getOperation()
        {
             return new IntMultiplyOperation();
        }
    }

- Yukarıda yazılan örnek normal şartlar altında runtime'da bir exception fırlatır. Çünkü bir uygulama içinde aynı
  referans'a dönen bean'lerin isimleri aynı olamaz. Bu durum qualifier annotation'ı ile çözülür.
  @Configuration
  public class OperationConfig {
      @Bean("OperationConfig.getOperation2")
      public IOperation getOperation2()
      {
          return new IntMultiplyOperation();
      }
      @Bean("OperationConfig.getOperation")
      public IOperation getOperation()
      {
           return new IntMultiplyOperation();
      }
  }

  @Configuration
  public class OperationConfig2 {
      @Bean
      public IOperation getOperation2()
      {
          return new IntMultiplyOperation();
      }
      @Bean
      public IOperation getOperation()
      {
          return new IntMultiplyOperation();
      }
  }

- Bir program da bir bean ismi unique olmalıdır. Aynı referansa dönsün yada dönmesin aksi durumda error oluşur.

- Bir program içerisinde qualifier annotation'ı ile belirtilmiş bir bean injection işleminde kullanılabilmesi için
  injection yapılacak yerde  qualifier annotation'ı bean'in ismi  bildirilmelidir. Yanlış bir qualifier isminde error
  oluşur. Qualifier ismi bildirilmez ise eğer tek bu injection'a atanabilecek tek bir bean var ise error
  oluşmaz. Birden fazla bean var ise, Bu bean'lerden primary işaretlenmiş olan bir bean var ise o bean atanır.
  Eğer herhangi bir bean yok ise runtime error oluşur.

- Qualifier bildirilmiş bir bean qualifier işaretlenmemiş bir metoda atanabilir. Eğer bu parametre bu bean ismi ile
  işaretlenir ise sadece bu bean atanabilir.

--- Primary annotation ----

- Bir bean primary işaretlendiği zaman herhangi bir şekilde bean ismi ile istenmez ise birden fazla bean içerisinden
  primary işaretlenmiş olanı verir. aynı referansa geri dönen birden fazla primary işaretlenmiş bean'ler olamaz.

--- Spring boot ile maven library'si oluşturmak ---

- Hocanın verdiği general template lib'den oluşturulur. Elde edilen jar çalışabilen bir jar değildir.

------------------------------------------------------------------------------------------------------------------------
                        Value annotation'ı ve properties dosyası
------------------------------------------------------------------------------------------------------------------------

- Spring boot projelerinde uzantısı .properties olan bir dosya vardır. Bu dosya yeni nesil spring projelerinde kullanılan
  bir dosyadır.

- Bu dosya projenin resources bölümünde otomatik olarak gelen bir dosyadır. Bu dosya bir script dosyasıdır.
- Bu dosyada belirtilen
    <isim> = <değer> araçlar kullanılır. Spring boot bu dosyayı parse eder.
- Bu isim ve değerler ilgili proje içerisinde kullanılabilir.
- Bazı araçlar(Hibernate,JPA, Spring boot, Spring web) buradaki isimleri tanıyıp eğer dosyaya yazılır ise ona göre işlem
  yapar.

- Bu dosyada ki yorum satırları # ile başlatılır. Bu yorum satırları shell script'lerde klasik bir şekilde böyle
  belirtilir.

- Bu dosya bizim için çok önemli bir dosyadır.

- Bu dosya sayesinde bir methoda injection işlemi yapılabilir.
- @Value annotation'ına $ ve küme parantezi içerisinde bir isim verilirse(@Value("${name}")) program ilgili ismi proper
  ties dosyasında bu isme karşılık gelen değeri argüman olarak geç demektir.

@Configuration
public class CalculatorRunnerOperation1Config {
    private final SampleCalculator m_sampleCalculator;

    public CalculatorRunnerOperation1Config(SampleCalculator calculator)
    {
        m_sampleCalculator = calculator;
    }

    @Bean("calculatorRunneroperation1")
    public ApplicationRunner runCalculator(@Value("${op1.a}")int a, @Value("${op1.b}")int b,@Value("${op1.op}") char op)
    {
        return args -> {
            System.out.println("CalculatorRunnerConfig.runCalculator");
            m_sampleCalculator.calculate(a, b, op);
        };
    }
}

- Yukarıdaki örnekte runCalculator metodu spring boot tarafından çağırılırken, properties dosyasındaki ilgili isme sahip
  değerleri bu fonksiyona argüman olarak geçilmesini sağlar.

- Eğer properties dosyasında ilgili isim bulunamaz ise runtime da exception oluşur. Böyle durumlarda bu isim yerine
  default olarak kullanılabilecek bir isim geçilebilir.

@Configuration
public class CalculatorRunnerOperation1Config {
    private final SampleCalculator m_sampleCalculator;

    public CalculatorRunnerOperation1Config(SampleCalculator calculator)
    {
        m_sampleCalculator = calculator;
    }

    @Bean("calculatorRunneroperation1")
    public ApplicationRunner runCalculator(@Value("${op1.a:5}")int a, @Value("${op1.b}")int b,@Value("${op1.op}") char op)
    {
        return args -> {
            System.out.println("CalculatorRunnerConfig.runCalculator");
            m_sampleCalculator.calculate(a, b, op);
        };
    }
}


- @Value("${op1.a:5}")int a ile eğerki op1.a ismi properties dosyasında bulunamaz ise bunun yerine 5 değeri ile çağrıl
  ması sağlanır. Bir default değer gibi kullanılmasını sağlar.

- Properties dosyaları aynı zamanda configürasyon dosyalarıdır.

- Value annotation'ı içerisinde kullanılan bu dile SpEL(Spring Expression Language) denir. Başka annotation'lar ile de
  kullanılabilir. Özellikle Value içerisinde kullanılır.

- Bu dosya ve Value annotation'ı çok önemlidirler.


- properties dosyasında o dosya içerisinde bildirilmiş başka bir değişkene ${name} ile erişilir.

- Value annotation'ı sınıfın elemanlarına, metodlara, parametrelere ve annotation'lara verilen bir annotation'dır.
- Yani bir sınıfın veri elemanı da properties dosyasından  alınabilir.

- Bir jar dosyanın içerisinde gömülü bir properties dosyası da bulunur.
- Eğerki bu jar'ın bulunduğu klasörde bir properties dosyası var ise jar'ın içindeki properties yerine bu properties
  kullanılır. Klasördeki properties doyası jar'ın içindekini ezer.

- Yani properties dosyası gömülü bile olsa dışrıdan ayrıca bir konfigürasyon dosyası da kullanılabilir.

- Properties dosyaları ile  spring boot ile gelen özelliklerdir. Bir jar'ın içerisindeki properties default
  configürasyon dosyasıdır. Jar'ın bulunduğu klasördeki properties dosyası ise yeni konfigürasyon dosyasıdır.

- Bir jar dosyası çalıştırılken properties geçilebilir.
    - java -jar name.jar --op1.a=89

- Spring boot ile (Aşağıdaki işlemler properties dosyası için yapılan işlemlerdir.)
    - default konfigürasyon yapılabilir
    - Konfigürasyon dışarıdan alınabilir.
    - uygulama çalıştırılken konfigürasyonda değişiklikler yapılabilir.properties'de ilgili isim olsun yada olmasın
      verilen isim o program çalıştığı sürece geçerlidir.

------------------------------------------------------------------------------------------------------------------------
                                            19.07.2020
------------------------------------------------------------------------------------------------------------------------

- Java'da hangi teknoloji olursa olsun(JSP, JSF) web teknolojileri üzerine kurulu her şey servlet denilen sistematik
  üzerinde toplanır.

- Servlet java'nın web üzerindeki temel taşıdır. Yani java'da web işlemlerinde en alttaki yapıda servlet yapısı vardır.

- Servlet kullanılmaması durumunda socket api'ler kullanılır. Bununla birlikte servlet dışında kendimiz server işlemleri
  ni ele alırız.

- Servlet'in sorumlu olduğu bir çok şey vardır.
    - Request'leri karşılamak
    - Uygun bilgileri request ile alıp response'ı dönebilecek şekilde bir takım işlemleri beraberinde getirir.

- Servlet java'nın uzak makineler ile haberleşmesinde özellikle web servis veya web uygulamalarının dayandığı teknolojiye
  denir.

- http'nin bazı çok önemli metodları vardır. Client bir istekte bulunduğunda özellikle get ve post metodlarını kullanır.
  Client bir request'in nasıl yapıldığını server'a söyler(post veya get).
    - get -> adresiyle beraber elemanların ? ile url'in yanına takılmasıdır.
    - post -> iletilen verilerin header'lara yazılmasıdır.
    - delete -> güvenlik gerekçesi ile pek kullanılmaz
    - put -> güvenlik gerekçesi ile pek kullanılmaz

- Bir istekte bulunulduğunda bir response döndürülür. Bu request ve response'ın nasıl yapıldığı uygulamanın temelini
  oluşturur.
- Eğer response bir html sayfası ise bunlara genel olarak web uygulaması denir.
- Eğer response özel bazı formatlar da ise(json, xml) bunlara rest service denir. Bu ayrım çok önemlidir.

- Eğer başka bir protokel üzerinden request ve response yapılır ise(örneğin soap) bunlara soap servisler denir. Soap
  servisler kullanımı giderek azalmaktadır.

- Ancak bunların temel amacı bir request ve response olmasu durumudur.

- Şu an genel olarak restful service'ler çok daha yaygın kullanılmaktadır.

- request hizmet alan veya müşteri anlamında kullanılır.
- server hizmet veren kişidir.

- Birbiriyle konuşan sistemler üzerinden konuşan uygulamarın geneline MICROSERVICE denir.


- Aşağıdakiler eskiden yapılan bir servlet uygulamasının nasıl yapıldığına ait aşağı seviyede nasıl çalıştığına yönelik bir
  örnektir. Spring boot bunların bir çoğunu bizim için elimine etmektedir.
- Bir servlet uygulaması aslında HttpServlet denilen bir sınıftan türetilmiş ve aynı zamanda bir takım annotation'lar
  ile işaretlenmiş olması gerekiyor. HttpServlet sınıfı içerisindeki bir takım metodların override edilmesi  gerekmektedir.
- Örneğin server'a gelen bir get request'i için doGet denilen bir metod çağırılır. iki adet prametresi vardır. request
  ve response'dır. request'in türü HttpServletRequest  bu metodun birinci parametresi(Bu sınıf gerektiği yerde kullanılır.)
  HttpServletResponse bunun ikinci parametresidir(Bu sınıfa ihtiyacımız olmayacaktır. Spring boot bu sınıfın yapacağı
  bütün işlemleri yapacaktır.).

- Sring boot yukarıda yapılan işlemleri sarmalayarak doGet ve doPost methodunu override etmek yerine çok daha yüksek
  seviyeli bir şekilde kodu yazmamızı sağlar.

- Controller : request ve response'ları verilerle birlikte yöneten katmandır. Bu controller'ın görevi gelen isteği ilgili
  metoda yönlendirir. Bu metodlara action metodlar denir.

- Eğer controller'ın döndüğü cevap bir html sayfası ise buna web uygulaması denir. Eğer cevap json veya xml formatında
  ise buna rest service denir.

- servlet üzerinde çalışan bir uygulamayı bir web application server tarafından çalıştırılıp yönetilmesi gerekir. Bu
  programlar:
    - Tomcat
    - Jboss
    - Glansfish
    - websphere

- Client tarafından istekler yukarıda yazılan uygulamalardan herhangi birine gelir ve bu uygulamalar akışı servlet'e
  yönlendirir.
- Bizim web tarafını organize eden uygulumalara web application server'lardır.
- spring boot uygulamalarında embbedded tomcat web dependency'si ile  beraber gelen bir web application server'dır.

- Tcp-ip protokolünde transmission port denilen bir port vardır. Bu server ile yapılan bilgi alışverişinde bilginin başka
  bir port üzerinden iletilmesidir.

- Transmission port Server'ın ip adresindeki ilgili port'un bizim local'imizde veya server'da müsait olamama durumu
  üzerine veri alışverişinin başka bir port üzerinden gerçekleşmesidir. Transmission port her zaman kullanılır.

- Transmission port belirlenebilen bir port'tur. Ancak  belirlenmez ise işletim sistemindeki ilk müsait port kullanılır.

- LocalPort  : TransmissionPort'tur.
  RemotePort : ip'nin sonunda kullanılan port'tur.
  LocalAddress : uygulamanın kendi ip'si
  RemoteAddress : istemcinin ip'si
  RemoteHost :


- Bir request'te client program http metodu olarak belirleme yapmaz ise default metod get'tir.
  client program post metodu için header'a post yazılması gerekir.

- rest servisleri test ekmek için kullanılan bazı programlar
    - http -> httpie programıdır.
    - curl ->  curl ve http linux ve unix sistemler de default olarak gelir.
    - postman

- Embedded tomcat'in default port'u 8080'dir. bu port istenirse application.properties dosyasından
  değiştirilebilir.
  server.port=50500 -> bu satır sayesinde tomcat uygulamayı 50500'den erişir.
- server.port uygulama'nın jar dosyası çalıştırılırken de verilebilen bir bilgidir.
   javar -jar artifact_name.jar --server.port=50500

- HttpServlet sınıfı spring tarafından bir bean olarak verilmektedir.
- Spring de genel olarak php'deki controller yapısında olduğu gibi bir türetme kavramı söz konusu değildir.

- Bir controller belirtilirken bu işlem annotation'lar(@Controller, @RestController) ile yapılır.
- RestController annotation'ı aynı zamanda bir controller annotation'dır.


- RequestMapping annotation'ı
    - Bir url yönlendirilmesi için yapılan annotation'dır. RequestMapping annotation'ı sadece action metodlara değil
      aynı zamanda controller'ın kendisine de verilebilen bir annotation'dır.
    - Bu işlem için annotation'ın value isimli property'sine atama yapılmalıdır.

    @RestController
    @RequestMapping("/info")
    public class ServletInformationController{
    //.. http://ip:port/info -> url'i ile bütün sınıflar buraya erişir.
    }

- Kısaca RequestMapping annotation'ı kendisine verilen value değerine göre bir sınıfa yada bir action metoda yönlendirme
  yapan annotation'dır.

- RequestMapping annotation'ı PostMapping ve GetMapping annotation'larını kapsayan bir annotation'dır.

- @PostMapping("/info") = @RequestMapping(value = "/info", method = RequestMethod.POST)
- @GetMapping("/") = @RequestMapping(value = "/", method = RequestMethod.POST)

- GetMapping ve PostMapping annotation'ları RequestMapping'i sadeleştirmek için kullanılan annotation'lardır.

- Controller nesnelerinin(RestController veya Controller) bir scope bildirimi yapılmaz ise scope'u singleton'dır.
- Bu özellik örneğin kullanıcıdan gelen isteğin zamanını almak istendiğinde önemli bir durumdur. Çünkü scope'u singleton
  bırakır isek ilk bağlantıdan sonra bir daha Controller nesnesi yaratılmayacağı için hep aynı zaman döner.

- Controller nesnesinin scope'u tamamen senaryomuza bağlı bir durumdur. Eğer ki singleton dışında bir durum gerekiyorsa
  scope'u değiştirmelidir.

- HttpServletRequest sınıfı kullanıcıdan gelen bir istekte kullanıcıya ve server'a ait bilgiler barındırmaktadır.
  Örneğin local Address = Server'ın local adresi,
          remote Address = client'ın adresi
          remote host =  proxy adresidir.
          localPort = anlaştıkları port,
          remotePort = veri alışverişinin yapıldığı port (transmission port) yani ilk müsait port


- client tarafından gelen her bir request için
    - spring tarafından HtppServletRequest nesnesi yaratılır(Kesin olarak yaratılmalıdır.).
    - İlgili Controller'a sahip action metod veya sınıfa yönlendirme yapılır.
    - çıktı iletilir(Çıktı iletilirken spring HttpServletResponse türünden bir yapı ile sonucu iletir. Ancak bu
      yapı alt seviyeli bir yapı olduğu için spring bizden bu hammaliyeyi alır.).

- Controller ile işaretlenmiş bir sınıf rest servislerde kullanılmaz. Controller annotation'ı ile işaretlenmiş sınıflar
  da action metodlar bir html sayfası döndürür.

- RestController ise web service'i(yani rest service'i) yayınlanmak için kullanılır.
- action metodlar için default root bulunmamaktadır. Bir action metod @GetMapping ile işaretlenmek .
    @RestController
    public class MyController{
        @GetMapping("/")
        public string foo(){return "foo"}
        /*
            public string foo(){return "foo"}
            Bu iki durum aynı değildir. Bir action metod @GetMapping ile işaretlenmelidir.
        */
    }

- Dünyada verilerin iletimini sağlayan bir takım formatlar vardır(JSON,XML). Bunlara ingilizce de data exchange format denir.
  Bu formatlar genellikle human-readable'dır(Basit string'ler biçimindedir.).

- Bir xml dosyasını parse edebilmek için bütün xml bilgisinin okunması gerekir. Mobil uygulamalar ile birlikte  XML gibi
  formatların kullanımı işi zorlaştırdığı için JSON formatı kullanılmıştır. Json formatını parse etmek için bir dosyanın
  tamamını kullanmak zorunda değildir.
  json formatının kullanımı :
    {
        key : value
        key2 : value2
        //.. şeklinde devam eder
    }

- spring boot default olarak json yayınlanır. Bu tarz service'lere restful services denir.

- spring boot'ta json formatı dönmenin en basit yolu ilgili türe dönüp o eğer istek get ise sınıfın getter'ları eğer
  istek post ise sınıfın setter'ları olmalıdır.

- spring boot'ta oluşturulan json formatı için key isimleri get metodlarının isimlerinin get'ten sonraki kısmın camelcase
  olarak yazılmış halidir. value ise'de ilgili get fonksiyonunun geri dönüş değeridir.

  örnek : public int getLocalPort(){
            return m_localPort};
        {
           localPort : 54040
           ..
        }
  şeklinde devam eder.

- bu spring'den kaynaklı oluşan bir durumdur.

- spring burada ilgili sınıfın sadece get metodlarında(eğer boolean ise is ile başlar.) yer alan bilgilerden bir json
   üretir. get ile başlamayan bir metod'u json'a eklemez.

- HttpServletRequest nesnesi bir request yapıldığında yaratılır ve her bir request'te ilgili request'e ait bütün
  bilgileri tutar.
- Spring web'de action metodlar eğer bir referans döndürüyorsa ve bu  referansın get metodları var ise bu durumda spring
  default olarak bu action metodunun geri dönüş değeri için bir json üretir.

------------------------------------------------------------------------------------------------------------------------
                                            25.07.2020
------------------------------------------------------------------------------------------------------------------------
- Katmanlı mimari verilerle işlem yapan bir uygulama da önemi daha çok ortaya çıkar.

- Repository Katmanı : veriler ile işlem yapan katmandır.
- Service katmanı : hizmet veren katman ->
- Application katmanı : Servis'ten hizmet alan katmandır.

- Katmanlı mimari her katmanı birbirinden ayırıp yapılacak işleri birbirinden bağımsız hale getirmektedir.

- entity : bir grup verinin bir tanesini temsil eden türdür.

- Genellikle service ve repository katmanları genelleştirilip öyle kullanılırlar. Bu durumlar da genelde interface
  kullanılarak yapılır.

- viewmodel ile dto sınıflar hemen hemen aynı işi yapan sınıflardır.

- genel olarak convert işlemleri serviste yapılmalıdır.

- Bir uygulama katmanından veri taşımak için dto(data transfer object) pattern'i kullanılır. Bu pattern sayesinde
uygulama katmanında kullanılan verinin repository'de kullanılan ile herhangi bir alakası yoktur.

------------------------------------------------------------------------------------------------------------------------
                                            26.07.2020
------------------------------------------------------------------------------------------------------------------------

- Http Get işlemleri :

- Get parametreleri url'in sonuna eklenerek gönderilir.
    http://localhost:8080/invoices/invoice?mon=1;

- Http'nin get metodlarındaki parametreyi yakalamak için kullanılan annotation @RequestParam annotation'ıdır.

- RequestParam annotation'ının value attribute' olmaz ise kendisine gelen request'teki isim ile aynı olmalıdır.
    örneğin
    @RequestParam int month
    http://localhost:8080/invoices/invoice?mon=1 // mon=1 yukarıdaki annotation ile yakalanamaz.

     @RequestParam int month
     http://localhost:8080/invoices/invoice?month=1 //ok

     veya

     @RequestParam("mon") int month
     http://localhost:8080/invoices/invoice?mon=1 //ok

- Url'den gelen her istek bir string olarak gelir. Spring bizim için RequestParam ile işaretlenmiş tür ne ise o türe
  dönüşüm yapar. Dönüşüm yapılamaz ise Exception oluşur. Exception spring tarafından  ele alınır. Kendi yazacağımız kod
  ile de exception'ı handle edebiliriz. Bu kısım ileri de ele alınacaktır.

- RequestParam annotation'ınının önemli bazı attribute'ları
      value, name = get metodunda key, value pair'indeki key'in ismini verdiğimiz kısımdır. Hiç bir değer verilmez ise
      parametrenin ismi ne ise o key o isim olur.
      required = boolean -> default'u true'dır. bu parametrenin geçilip geçilmemesi gerektiğini belirler.
      defaultValue = string -> required false geçildiği zaman bir defaultValue verilip verilmeyeceğini belirler.

    @GetMapping("/invoicemonth")
    public Iterable<InvoiceDTO> getInvoicesByMonth(@RequestParam(value = "mon", required = false, defaultValue = "0") int month)
    {
        if (month <= 0)
            month = LocalDate.now().getMonthValue();
        return m_invoiceService.findAllInvoicesByMonth(month);
    }

    - yukarıdaki action metod için bazı url ömrnekleri
        http://localhost:8080/invoices/invoicemonth -> month değeri o an bulunan ayın değeridir.
        http://localhost:8080/invoices/invoicemonth -> month değeri o an bulunan ayın değeridir.
        http://localhost:8080/invoices/invoicemonth?mon=5 -> month değeri 5'dir.
        http://localhost:8080/invoices/invoicemonth?mon=-1 -> month değeri o an bulunan ayın değeridir.
        http://localhost:8080/invoices/invoicemonth?mon=ali -> hata oluşur. badrequest alırız.


- Http Post işlemleri

- Post işlemlerinde ilgili parametrenin yakalanması için @RequestBody annotation'ı kullanılır.

- Post işlemlerinde gönderilen bilgi sınıfın set metodunun isimlerindeki bilgi şeklinde gönderilmelidir.

- Katmanlı mimaride herhangi bir katmanda oluşabilecek bir hata yukarıya aynen iletilirse bu durumda katmanlı mimarinin
  herhangi bir anlamı kalmayacaktır. Bu durumda oluşabilecek hatalar yukarıya sarmalanarak gönderilmelidir.

- Repository de oluşan bir hata servis katmanına repositoryException olarak, service'te oluşabilecek bir hata'da uygulama
  katmanına service exception olark gönderilmelidir. Repository'den servise giden hata'lar da istisna olabilir ancak
  servisten uygulamaya gidecek hatalar mutlaka sarmalanmalıdır.

- Spring bit exception oluştuğunda da bu exception'ı sarmalayarak gönderir(IllegalStateException'dır.).

-------- FACADE DESIGN PATTERN -------

- facade design pattern'i birden çok benzer işi yapan sınıfları tek bir sınıf altında toplamak için kullanılır. Bu işlem
  basitleştirme amaçlı kullanılır. Birden fazla sınıfı aynı anda birleştirip aynı

- Örneğin bir çok projede birden çok repository sınıfı vardır. Ve her bir repository için ayri birer sınıf bulunur. Buradaki
  amaç bu repository referans'larını tek bir sınıfta toplayıp ilgili repository'nin methodlarını kullanır.

- facade kalıbı birden çok repository olduğunda kullanılan bizim projelerimizde service'e basitleştirmek için kullanılır.

- facade ayrıca bir grup bilgiyi ayrı ayrı kullanmak yerine tek bir yerden kullanılmasını sağlar.

------------------------------------------------------------------------------------------------------------------------
                                            08.08.2020
------------------------------------------------------------------------------------------------------------------------

- MavenLibraries'den DbUtilLib oluşturuldu.

- Url'den girilen bir örneğin http://localhost/8080?mon=ali gibi bir url için Spring tarafından bir BAD_REQUEST kodu döner.

- Bize Spring tarafından üretilen hata kodunu işlemeden önce işlem yapabilmemizi sağlayan bir sınıf vardır. Bu sınıfın ismi
  ResponseEntityExceptionHandler'dır. Bu sınıftan yapılan bir türetme ile beraber kendi hata kodumuzu Json olarak dönebiliriz.

- Bu sınıftan türetilecek sınıflar @ControllerAdvice annotation'ı ile işaretlenmelidir. Bu sayede Controller sınıflarına
  bir hata durumunda programcının bu sınıfta yazmış olduğu metodlara bakacağı bildirilir.

- Bu sınıfta yapılacak işlemler bir response dönmek olduğu için, bu işlemler uygulamanın application katmanında olur.
- Bu sınıfta birden çok sebepten oluşabilecek hataları spring'den önce işlemek için kullanılan metodlar vardır.
- Bu sınıfın override edilen metodları request'ten gelen ve bu durum sonucu oluşabilecek exception'ları yakalar.
- handleTypeMismatch override edildiği zaman Spring içerisinde oluşabilecek tür dönüşmesinden kaynaklı herhangi bir exception
  sonucu geri döndürelecek cevabı göndeririz.


------------------------------------------------------------------------------------------------------------------------
                                            15.08.2020
------------------------------------------------------------------------------------------------------------------------

- ResponseEntityExceptionHandler'dan türetilmiş sınıfa(ControllerAdvice ile işaretlenmiş olmalıdır.) eklenen metodlar
  (override edilen metodlar değildir.)ile kendimizin gönderdiği exception'lar alakalı işlemler yapılabilir. Bu sayede
  oluşabilecek bir exception try-catch içerisine alınmadan(normal bir java uygulaması exception oluşması durumunda
  çöker.), exception durumunda yapılacak metodu belirlenir. Bu metod ExceptionHandler annotation'ı ile işaretlenmelidir.
  ve value değeri olarakda hangi exception  ile işlem yapılacak ise o exception'ın class'ı verilmelidir.

  @ExceptionHandler(ServiceException.class)
  public ResponseEntity<Object> handleServiceException(ServiceException ex)
  {
    var apiError = new ApiError(/*.....*/);
    return new ResponseEntity(apiError, apiError.getHtppStatus());
  }
- Yukarıdaki gibi yazılacak metodlar mutlaka ResponseEntity dönmelidir. Bu metodlar sğ


- Response entity'siz gönderilen bir response her zaman 200 yani başarı kodu ile döner. ResponseEntity ile ilgili kodun
  Http statü kodunu da değiştirebiliriz.


------------------------------------------------------------------------------------------------------------------------
                                            Jackson api
------------------------------------------------------------------------------------------------------------------------

- Jackson api bazı json elemanlarını formatlamak için kullanılan bir yapıdır(Sadece bu amaçla kullanılmaz.).

- Örneğin bir tarih formatını değiştirmek için Jackson api kullanılır.

- Bu api'nin JsonFormat annotation'ı ile ilgili üye değişkeninin formatı değiştirilebilir.
- JsonFormat annotation'ı get metodlarının başına konularak json yayınlanırken istenilen formatta json yayınlanmasını
  sağlar.

- Formatlama işlemi özellikle tarih'ler için anlamlı olmaktadır.

- JsonFormat annotation'ının tarih formatlamak için kullanılan iki önemli attribute'ı vardır.
    1-) shape -> girilecek formatın hangi biçimde(string, dizi) girileceğini gösterir. shape'in türü JsonFormat.Shape
        enum'ı türündendir.
        - shape = JsonFormat.Shape.STRING -> girilecek format string türündendir.
    2-) pattern
        - pattern = "dd-MM-yyyy"; // büyük MM olmak zorundadır. mm dakika anlamına gelir. Bu yüzden ay için büyük yazılmalıdır.

------------------------------------------------------------------------------------------------------------------------
                                            16.08.2020
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
                                            JDBC
------------------------------------------------------------------------------------------------------------------------

- Java'nın veri tabanı yönetim sistemine erişebilmek için en temel, bütün hepsinin kullandığı bir yapı vardır. Bu yapıya
  JDBC(Java DataBase Connectivity) api denir. Jpa, Hibernate, Eclipselink gibi araçların hepsi alt tarafta jdbc
  kullanmaktadır.

- JDBC api standartı, veri tabanına sql cümleciklerine gönderebilmek için gereken araçları içeren sınıflar topluluğudur.

- Bu standartlar birer driver ile çalışır.

- Bir veri tabanı yönetim sistemine erişebilmek için o veritabanı sistemine özgü sınıfların içsel olarak
  çalıştırılması gerekir. Bu sınıfların bir standartı olmadığından, JDBC bunlara driver'lar ile erişir ve bunların
  temel sınıfı DriverManager sınıfıdır. Bu ürünleri(Oracle, Mysql, Postgresql) yazan firmalar bu ürünlere yönelik
  driver'ları barındırır.

- Bir veri tabanı ürünü üzerinde java ile işlem yapabilmek için ilgili veri tabanı ürününün driver'larına ihtiyaç vardır.

- Biz bu driver'ların jar dosyalarını aslında sisteme dahil ederiz. Reflection yöntemi ile runtime'da bu jar dosyalarına
  bakılarak connection işlemleri yapılır.

- JDBC driver'ları için ilgili ürüne yönelik driver'ların projeye eklenmesi gerekir.

- Jar'ların hepsi maven'la alındığı için sorun olmayacaktır. Ancak bu işlemin manuel yapılması durumunda ilgili jar dosyası
  indirilip ilgili yere kurulmalıdır.

- Spring boot'un doğrudan dependency injection ile jdbc elamanlarını elde edebileceğimiz bir starter'ı vardur.
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>


- jdbc içerisindeki en temel sınıf JdbcTemplate sınıfıdır. Bu sınıf doğrudan dependency injection ile oluşturulabilir.

- bu paket kurulduktan sonra doğrudan program çalıştırılmaya çalışıldığında program çöker. Bunun için
  application.properties dosyasına bir takım bilgiler yazılmalıdır.

  1-) hangi veri tabanı
    - spring.datasource.url=jdbc:postgresql(hangi veri tabanı kullanılıyor ise o yazılmalıdır.)://localhost:5432/database_name
  2-) veri tabanı kullanıcısı
    - spring.datasource.username=postgres
  3-) kullanıcı şifresi
    - spring.datasource.password=csd1993

- JdbcTemplate sınıfının bir çok metodu vardır. Bu metodların özellikle belirli elemanları vardır.
- Örnek olarak sorgulama işlemi yapan query adlı metodu vardır. ve query metodunun RowCallbackHandler adlı bir functional
  interface referansı ister.
  void query(String var1, RowCallbackHandler var2);

- RowCallbackHandler interface'i bizden bir ResultSet alır. RowCallBackHandler aslında bizden arka planda ne yapacağını
  istemektedir.

- ResultSet sınıfı bir query işlemi yapıldığında bize verilen bir collection'dır.
   m_jdbcTemplate.query(m_findAll, (ResultSet rs) -> findAllHandler(rs, invoices)); // lambda parametresi için ResultSet
   türünü koymaz isek derleyici lambda ifadesine uygun iki farklı method bulacağından error verir. Bu yüzden lambda
   parametresinin türü belirlenmelidir..

- ResutSet sınıfı aslında bir set collection'ıdır. ResultSet içerisinde hiç eleman yoksa lamba'nın atandığı functional
  interface'in ilgili metodu hiç çağrılmamaktadır.
- Yukarıdaki sebepten kaynaklı ResultSet dolaşılırken do-while ile dolaşılmalıdır. ResultSet collection'ı dolaşılırken
  next metodu kullanılır. Bu metod checked bir exception olan SQLException fırlatır. Bu yüzden throws  bildirimine yazılması
  gerekir.
     private void findAllHandler(ResultSet resultSet, Iterable<Invoice> invoices) throws SQLException
     {
         do {

         } while (resultSet.next());
     }

- ResultSet'in get ile başlayan metodları ile get metoduna verilecek anahtar veya index numarası ile bu numaraya karşılık
  gelen değerler geri döndürülür.
- Burada veritabanında tutulan alanların türlerinin bilinmesi zorunludur.
- ResultSet'e verilecek index numarası 0'dan değil 1'den başlar. Java'da index numarasının 1'den başladığı tek yer
  burasıdır.

- Veri tabanında oluşturulan money türleri ResultSet içerisinde bigdecimal olarak alınamaz. Çünkü veritabanında
  kaydedilirken , ile ayrılır. Bunun ayarı postgresql de yapılmalıdır.

- Java'nın Jdbc api'leri java.util.Date sınıfından türetilmiş java.sql.date sınıfını kullanmaktadır. Bu sınıfın toLocalDate
  metodu ilgili sınıfı LocalDate sınıfına çevirir.

- ResultSet'in getDate fonksiyonu da java.sql.Date türünü geri döndürür. Bu türü toLocalDate metodu ile LocalDate türüne
  çevirebiliriz.

- query fonksiyonanına verilen sql cümlesinde argümanları daha sonradan geçebiliriz.
    postgresql.invoices.findByMonth=select * from invoices where date_part(month,date) = ?
- yukarıdaki script'e soru işareti bir değişkeni belirtmektedir.
- bu değişkenin kullanımı query fonksiyonunda gerçekleştirir.
    @Override
    public Iterable<Invoice> findInvoicesByMonth(int mon)
    {
        var invoices = new ArrayList<Invoice>();

        m_jdbcTemplate.query(m_findInvoicesByMonthSql, new Object[]{mon}, (ResultSet rs) -> fillInvoices(rs, invoices));//fillInvoices repository sınıfında private metoddur.

        return invoices;
    }
------------------------------------------------------------------------------------------------------------------------
                                            23.08.2020
------------------------------------------------------------------------------------------------------------------------

- DBUtilLib checked exception'lar içinde genelleştirildi. DBUtil sınıfının Supplier  ve Runnable'ın kullandığı metodlar
  yerine ISupplierCallback ve IActionCallback functional interface'leri eklendi.


- ResultSetExtractor inteface'i ile bir sql sorgusu sonucu elde edilen bir data'yı bize döndürür. Bu sınıf fonksiyonel
  bir interface'dir. ve geri dönüş değeri sınıfın T açılımıdır.
    @Override
    public long count()
    {
        return m_jdbcTemplate.query(m_invoicesCountSql, (ResultSet rs) -> rs.getInt(1));
    }

- ResultSetExtractor inteface'i, RowCallbackHandler inteface'i gibi iterator'u 1 ilerleterek
  kodu çalıştırmaz. ResultSetExtractor sınıfını kullanırken ilgili iterator'u bir ilerletip
  öyle ResultSet'in metodlarını çalıştırmamız gerekir.

  @Override
  public long count()
  {
      return m_jdbcTemplate.query(m_invoicesCountSql, (ResultSet rs) -> {rs.next(); return rs.getInt(1); });
  }

------------------------------------------------------------------------------------------------------------------------
                                            29.08.2020
------------------------------------------------------------------------------------------------------------------------

- Bir string nasıl tekrar edilir.
    1- java 11 ile eklenen repeat fonksiyonu String s = "a"; s.repeat(n); since java 11
    class Util {
        public static String repeat1(int n, String s)
        {
            return Stream.generate(() -> s).limit(n).collect(Collectors.joining());
        }
        public static String repeat2(int n, String s)
        {
            return IntStream.rangeClosed(1, n).mapToObj(i -> s).collect(Collectors.joining());
        }
        public static String repeat3(int n, String s)
        {
            return String.join("", Collections.nCopies(n, s));
        }
        public static String repeat4(int n, String s)
        {
            return Collections.nCopies(n, s).stream().collect(Collectors.joining());
        }
        public static String repeat5(int n, String s)
        {
            return String.format("%0" + n + "d", 0) //%04d -> "0000"
                    .replace("0", s);
        }
        public static String repeat6(int n, String s)
        {
            return String.format("%0" + n + "c", ' ') //%04d -> "0000"
                    .replace("0", s);
        }
    }

- inner class'lar  kullanılırken  bellek sızıntısı oluşturan çok önemli bir kod senaryosu vardır.
    class Sample {
        private int m_x;

        private  Mample m_mample;

        private class Mample {
            private void bar(int x)
            {
                m_x = x;
            }
        }

        public Sample()
        {
            m_mample = new Sample();
        }
    }

- Yukarıda yazılan kodda Mample sınıfının içerisinde  Sample sınıfının ilgili objesinin tutulduğu bir referans olduğu için
  Sample sınıfınnın ilgili nesnesinin referans sayacı asla 0'a düşmez. Sample nesnesi ölmediği için mample nesnesinin
  sayacıda 0'a düşmez. Böyle durumlara deadlock denir.

- Bu sorunun çözüm yollarından birisi sample sınıfının Closeable interface'ini implemente edip ölmeden önce ilgili mample
  referansını 0'a düşürüp mample'ın gördüğü Sample sınıfının ilgili referansının'da sıfıra düşmesi sağlanır.
    class Sample implements Closeable {
        private int m_x;

        private  Mample m_mample;

        private class Mample {
            private void bar(int x)
            {
                m_x = x;
            }
        }

        public Sample()
        {
            m_mample = new Mample();
        }

        public void close()
        {
            m_mample = null;
        }
    }

- Bu sorunun başka bir çözümü ise WeakReference sınıfı ile'dir. Bu sınıf ile gösterilen bir nesneyi ilgili WeakReference
  dışında gösteren bir referans yok ise ilgili nesne garbace collected hale döner.
  class Sample {
      private int m_x;

      private  Mample m_mample;

      private static class Mample {
          private WeakReference<Sample> m_sampleWeakReference;
          private Mample(Sample sample){
              m_sampleWeakReference = new WeakReference<>(sample);
          }
          private void bar(int x)
          {
              m_sampleWeakReference.get().m_x = x;
          }
      }

      public Sample()
      {
          m_mample = new Mample(this);
      }

  }

- normal şartlar altında JdbcTemplate ile yapılan bir save metoduda otomatik artan id'yi almak mümkün değildir. Çünkü
  otomatik artan id database tarafından sağlanır(Aslında bir yöntem vardır ancak her sınıf için çalışmaz.).
- Otomatik olan bir id'yi almak için bazı yöntemler vardır. Ama bu yöntemlerden bazıları her bir DBMS için çalışmıyor.
  Örneğin JdbcTemplate üzerinden KeyHolder ile almak postgresql için çalışmaz.

- Burada her database çalışabilen bir sınıf vardır. Bu sınıf JdbcTemplate sınıfından farklı bir sınıftır.
  Bu sınıfın adı NamedParameterJdbcTemplate'dır. JdbcTemplate ile yapılabilen her işlem bu sınıf ile yapılabilir. Bu
  sınıfta JdbcTemplate için kullanılan sql sorguları içinde kullanılan ? yerine başka bir yapı kullanılır. JdbcTemplate
  için ? örneği(select * from invoices where invoice_id = ?)

- KeyHolder interface'i ile otomatik artan id elde edilir. Bu interface'i implemente eden GeneratedKeyHolder sınıfı
  kullanılacaktır.

- application.properties dosyasında kullandığımız sql cümlelelerinde ? yerine isimli parametreler kullanılır. Bu yapı SqlParameterSource
  interface'ini kullanan yapılar için kullanabilir. Projemizde bu yapıyı NamedParameterJdbcTemplate' sınıfının update
  fonksiyonunda kullanıyoruz. Bu yapıyı'da repository'de save metodunda kullandık.
    insert into invoices (name, address, date, total) values (:name, :address, :date, :total)

- Yukarıda kullanılan yapı NamedParameterJdbcTemplate kullanıldığı zaman yapılabilen bir yapıdır.

- application.properties dosyasında sql cümlelerimizi tutmak pek uygun bir durum değildir. Bunlar global bir sınıfta veya
  ilgili repository sınıfında tutulmalıdır.

- JdbcTemplate ile yapılan her işlem NamedParameterJdbcTemplate ile de yapılır. Bu işlem'lerdeki farklılık aşağıdaki gibidir.

  JdbcTemplate için
  private static final String FIND_BY_DATE_SQL = select * from invoices where date = ?
  @Override
   public Iterable<Invoice> findInvoicesByDate(LocalDate date)
   {
       var invoices = new ArrayList<Invoice>();

       m_jdbcTemplate.query(FIND_BY_DATE_SQL, JDBCUtil.getArguments(date), (ResultSet rs) -> fillInvoices(rs, invoices));

       return invoices;
   }

  NamedParameterJdbcTemplate için

  private static final String FIND_BY_DATE_SQL = select * from invoices where date = :date

  public Iterable<Invoice> findInvoicesByDate(LocalDate date)
  {
      var invoices = new ArrayList<Invoice>();
      var args = new HashMap<String,Object>();
      args.put("date", date);
      m_namedParameterJdbcTemplate.query(FIND_BY_DATE_SQL, args, (ResultSet rs) -> fillInvoices(rs, invoices));

      return invoices;
  }

  - hashMap'in açılımının ikinci tür parametresinin Object olmasının nedeni genel bir kullanım içindir. put ettiğimiz ilk
    parametre ile FIND_BY_DATE_SQL içerisinde kullanılan :'dan sonraki değerin aynı olması gerekir.

- NamedParameterJdbcTemplate sınıfının update metodunun yapısı
    1. parametre Sql cümlesi
    2. parametre SqlParameterSource interface'i -> bu interface'i new BeanPropertySqlParameterSource sınıfı gönderilir.
       Bu sınıf constructor'ına verilen object'in get metodlarına bakarak ilgili parametrelerin değerlerini yerleştirir.
    3. parametre Keyholder   -> otomatik artan id'yi almak için kullanılır.
    4. parametre String [] ->   hangi id'lerin veri tabanından alınacağını ilgilendiren örnektir. Bizim örneğimizde
                                invoice_id'yi istediğimiz için String olarak sadece o geçilmiştir.

    keyholder'ın geri dönüş değeri number türündendir. Bundan dolayı id'miz hangi türden ise o türe ilişkin metod çağrılmalıdır.
    private static final String SAVE_SQL =  "insert into invoices (name, address, date, total) values (:name, :address, :date, :total)";
    @Override
    public <E extends Invoice> E save(E entity)
    {
        KeyHolder keyHolder = new GeneratedKeyHolder();
        m_namedParameterJdbcTemplate.update(SAVE_SQL, new BeanPropertySqlParameterSource(entity), keyHolder, new String[]{"invoice_id"});
        entity.setId(keyHolder.getKey().intValue());
        return entity;
    }

- DBMS'de bir kullanım şekli vardır. Bu yapıya ORM yaklaşımı denir.
------------------------------------------------------------------------------------------------------------------------
                                            ORM (Object Relation Model)
------------------------------------------------------------------------------------------------------------------------
- Object relational model yaklaşımında her bir sınıf veri tabanında bir obje'ye karşlık gelir.
- Bu yapı otomatik olarak orm yapılarının mekanizması ile sağlanır.

- Orm yapılarının en temelde java düzeyinde kullanımı için standart olarak jpa(java persistence api) kullanılır.

- Jpa'in farklı implementasyonları vardır. Örneğin Eclipse-link implementasyonları bunlardan biridir.

- Bu implementasyonlardan en tipik kullanımı özellikle spring 5'den sonra annotation'larını jpa'e de çok yakınlaştırdığı
  için hibernate denilen bir yapı kullanılmaktadır.

- hibernate arka planda jpa'i kullanan(jpa arka planda jdbc'yi kullanmaktadır.) bir orm yaklaşımı kullanımıdır.

- spring framework'unde (boot) jpa ile hibernate birlikte çalışmaktadır.
- Bu yapıların kendilerine özgü bir dili vardır. Bu dile jql(jpql'de olabilir) denir.
- Biz sorgularmızı yazarken hibernate query language veya jpql(jpa query language) yapısı kullanıyoruz.

- bunların sql'den farklı olarak kendi sorgulama sentaksları vardır.

- bu yapılar bazı şeyleri kolaylaştırmak için kullanılır. Bu yüzden de library gereksinimleri vardır.

- jpa dependency eklendiği zaman, arka tarafta hibernate dependency'si de eklenir. bu duruma out of box denir.

- jpa eklendikten sonra application.properties dosyasında değişiklik yapılması gerekmektedir.

- spring.jpa.hibernate.ddl-auto= -> buna atanabilecek değerler aşağıdakilerdir.
    create -> uygulama her ayağa kalktığında eski tablolar uçup yenisi getirilir.
    create-drop -> uygulama ayağa kalktığında tablolar yaratılır. uygulama kapatıldığında tablolar silinir.
    none -> veri tabanında her şeyin hazır olduğunu ve programın veri tabanına bakmasına gerek yok anlamına gelir.
    update -> programcı tarafından verilen şema ile veri tabanı üzerindekileri update eder. Programcı tarafından belirlenen
              sınıflar ile tablolar yaratılır. Tablolar var ise herhangi bir silinme olmaz.
    validate -> daha sonra gelecektir.

- ddl-auto'ya atanan değer update ise bu yaklaşıma code_first yaklaşımı sınır. kod sınıflar ve entity'ler yazılır.
  entity'lerden tablolar oluşur.

- 100'lerce tablonun olduğu bir uygulamada code_first_from_database adlı bir teknik kullanılır. database'den kodları
  generate edilerek yapılır.

- javax.persistence(javax'a java exclusive paketi denir.). Javax paketinin altındaki persistence'ı jpa'in implemente edildiği bir yapıdır.

- javax.persistence paketinin @Entity isimli annotation'ı işaretlenmiş bir sınıf database de bir tabloya karşılık gelir.

- Entity ile işaretlenmiş sınıflarda yerel değişkenler'i bildirirken m_ kullanılmamalıdır.

- @Entity ile işaretlenmiş bir sınıfın bir primary key'i olmalıdır. primary key elemanı @Id annotation'ı ile belirtilir.

- tablolarda otomatik artan id'ler @GeneratedValue denilen bir annotation ile işaretlenmelidir.
  Bunun strategy değerine GenerationType.IDENTITY değeri ile işaretlenmelidir. Bu yapı ile dmbs'da bu elemanın
  otomatik artan id olduğu ismi verilir.

- Eğer bu veri elemanına herhangi bir column bilgisi verilmez ise bu elemanın veri tabanındaki ismi buradaki veri elemanı
  ile aynıdır.
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "invoice_id")
  //@Column(name = "id") // böyle yazmaya gerek yoktur. zaten bu isim direk olarak geçecektir.
  private int id;

- tablo ismi'de sınıf isminin default olarak küçük harfli olan halidir.
- tabloya isim vermek için @Table annotation'ının name elemanı kullanılır.

@Entity
@Table(name = "invoices")
public class Invoice {
    //..
}

- @Column annotation'ının birden fazla elmeanı vardır.
  Örneğin unique, nullable gibi ikisi de boolean değer alır.
    unique-> default false'dır.
    nullable-> default true'dır.

- Entity ile işaretlenmiş bir sınıfın default constructor'ı olmak zorundadır. private olabilir farketmez. Nedeni jpa
  ilgili entity'yi içi boş bir şekilde yaratır. Daha sonrasında içini doldurur.

- Spring boot ekibi CrudRepository<T, ID> denilen bir interface yazmışlardır. Yazdığımız ICrudRepository'deki metodların
  aynısı bu interface'de de vardır. Bu interface aslında bir patterndir.

- CrudRepository interface'i repository interface'inden türetilmiştir.

- JpaRepository denilen bir interface'de vardır. Buda CrudRepopository'den ve aynı zamanda PagingAndSortingRepository'i
  interface'inden türetilmiştir.

- CrudRepository'iden türetilmiş bir interface'imiz var ise veya CrudRepository türünden bir interface referansımız
  dependency injection ile istenir ise, CrudRepository'ye ait bütün metodlar otomatik yazılır.

- CrudRepository'den türetilmiş bir interface dependency injection ile istenir ise ilgili inteface'i implemente eden bir
  sınıf otomatik olarak spring tarafından yazılacaktır.

- CrudRepository'nin ilk parametresi bir tablonun karşılık geldiği entity olması gerekir.

- CrudRepository'nin metodları spring tarafından otomatik olarak yazılır. ancak o inteface'den türetilmiş interface'e ait
  metodların bazıları spring tarafından yazılmaz.

- interface IInvoiceRepository extends CrudRepository<Invoice, Integer> {
        Iterable<Invoice> findInvoicesByMonth(int month); // bu ve aşağıdaki iki metod spring tarafından yazılamaz.
        Iterable<Invoice> findInvoicesByDate(LocalDate date);
  }

- yukarıdaki metodların yazılması için hibernate query language veya jpql dediğimiz özel bir sentaks kullanımı gerekmektedir.

- Query annotation'ın value isimli elemanı ile hibernate query lanugage veya jpql yazmamız sağlanır.

- hibernate query language sql cümlelerine çok benzeyen taşınabilir olsun diye kendine özel bir sentaksa sahiptir.

- hibernate ql veya jpql iki türlü kullanılabilir.
    1- from ile başlayan yapıdır.
        @Query("from Invoice i where  i.date = :date") // Tabloya karşılık gelen entity isminin kullanımı zorunludur.
        Iterable<Invoice> findInvoicesByDate(LocalDate date);
    2- select ile başlar.
        @Query("select i from Invoice  i where i.date = :date")
        Iterable<Invoice> findInvoicesByDate(LocalDate date);


- @Query annotation'ı ile beraber native query'lerde yazılabilir. Ancak native query yazılacağı zaman hql veya jpql
  sentaksı değil hangi dbms üzerinde yazıyor isek ilgili database dilinde yazılması gerekir.

- Bunun için @Query'nin nativeQuery elemanının true geçilmesi gerekir.
    @Query(value = "select * from invoices where date_part('month',date) = :month", nativeQuery = true)
    Iterable<Invoice> findInvoicesByMonth(int month);
- veya :month yerine ? de kullanılabilir.
    @Query(value = "select * from invoices where date_part('month',date) = ?", nativeQuery = true)
    Iterable<Invoice> findInvoicesByMonth(int month);

- burada kullanılan database hangisi ise o database'a ait dil ile yazılması gerekir. Örneğin posrgresql için plpgsql
  sql server için t-sql olmak zorundadır.

- hql kullanırken hql @Entity annotation'ları ile işaretlenmiş annotation'ları kullanır.

- Şu ana kadar yazılan CrudRepository kodlarında tablo mutlaka bir sınıf ile eşleşmelidir. Büyük projelerdeki veri
  tabanlarında bize tablolara erişim hakkı verilmemektedir. Çoğunlukla bu tablolara erişmek için fonksiyonlar kullanılır.

- Yukarıdaki gibi bir durumda bizim veri tabanına erişimimiz hibernate ile sağlamamız gerekmektedir.

- CrudRepository'yi kullandığımız yerlerde bazı metodlar otomatik yazılabilir. Entity sınıfının herhangi bir veri elemanı
  eşleşecek metodlar findBy ile yazılabilir. veri elemanının DBMS'da ki unique olup olmamasına  göre geri dönüş değeri
  Optional<T> veya Iterable<T> belirtilmelidir. Optinal unique olan bir eleman için Iterable unique olmayan bir eleman için
  kullanılır.

-  IInvoiceRepository'de kullanılan findInvoicesByDate metodu jpa tarafından findByDate ile ismi ile otomatik olarak
   yazılabilir.
     @Query("select i from Invoice  i where i.date = :date")
     Iterable<Invoice> findInvoicesByDate(LocalDate date);
     yerine
     Iterable<Invoice> findBydate(Localdate date); //Jpa otomatik kodunu yazacaktır. findBy'dan sonraki kısım ile veri
     ilgili entity'deki isim aynı olmalıdır.

- Veri tabanında bir tabloya karşılık gelen(yani @Entity ile işaretlenmiş sınıflara) POJO(Plain Old Java Object) denir.

- Pojo genel olarak repository'de olur. Servis'e kadar çıkar. Servis'ten sonra uygulama katmanına değişmiş olarak gelebilirler.
- Bu değişim zorunlu değildir. Küçük uygulamalarda değişime gerek olmadan da bu işlem yapılabilir.Yani DTO sınıfları
  olmadan işlem yapılabilir.
 